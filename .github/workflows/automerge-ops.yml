name: automerge-ops
on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read
jobs:
  merge:
    if: >
      startsWith(github.event.pull_request.head.ref, 'ops/') &&
      contains(github.event.pull_request.labels.*.name, 'automerge') &&
      !contains(github.event.pull_request.labels.*.name, 'freeze')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const MAX_TRIES = 60; // 5분
            const SLEEP_MS  = 5000;
            const sleep = ms => new Promise(r => setTimeout(r, ms));

            async function allGreen() {
              // check runs
              const checks = await github.checks.listForRef({ ...context.repo, ref: pr.head.sha, per_page: 100 });
              const runsOk = checks.data.check_runs.every(c => c.status === 'completed' && c.conclusion === 'success');

              // commit statuses (contexts)
              const statuses = await github.repos.getCombinedStatusForRef({ ...context.repo, ref: pr.head.sha });
              const statusOk = statuses.data.state === 'success';

              return runsOk && statusOk;
            }

            let ok = false;
            for (let i=0; i<MAX_TRIES; i++) {
              if (await allGreen()) { ok = true; break; }
              await sleep(SLEEP_MS);
            }

            if (!ok) {
              core.notice('Required checks not all green yet. Skipping without failing.');
              return; // 비차단: 실패로 끝내지 않음
            }

            try {
              await github.pulls.merge({ ...context.repo, pull_number: pr.number, merge_method: 'squash' });
              core.notice(`Merged PR #${pr.number} via automerge-ops.`);
            } catch (e) {
              core.notice(`Automerge skipped (reason: ${e.message}).`);
            }
