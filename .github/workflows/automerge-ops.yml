name: automerge-ops
on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read
jobs:
  merge:
    if: >
      startsWith(github.event.pull_request.head.ref, 'ops/') &&
      contains(github.event.pull_request.labels.*.name, 'automerge') &&
      !contains(github.event.pull_request.labels.*.name, 'freeze')
    runs-on: ubuntu-latest
    continue-on-error: true             # ðŸ‘ˆ job ë ˆë²¨
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const MAX_TRIES = 60, SLEEP_MS = 5000;
            const sleep = ms => new Promise(r => setTimeout(r, ms));
            async function allGreen() {
              const checks = await github.rest.checks.listForRef({ ...context.repo, ref: pr.head.sha, per_page: 100 });
              const runsOk = checks.data.check_runs.every(c => c.status === 'completed' && ['success', 'neutral', 'skipped'].includes(c.conclusion));
              const statuses = await github.rest.repos.getCombinedStatusForRef({ ...context.repo, ref: pr.head.sha });
              const statusOk = statuses.data.state === 'success';
              return runsOk && statusOk;
            }
            let ok = false;
            for (let i=0;i<MAX_TRIES;i++){ if (await allGreen()){ ok=true; break;} await sleep(SLEEP_MS); }
            if (!ok) { core.notice('checks not passed yet; skipping'); return; }
            try {
              await github.rest.pulls.merge({ ...context.repo, pull_number: pr.number, merge_method: 'squash' });
              core.notice('PR merged ðŸŽ‰');
            } catch (e) {
              core.notice(`Automerge skipped (reason: ${e.message})`);
            }