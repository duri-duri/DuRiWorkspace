#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DuRi Phase Œ©: MetaCoder Engine

Ïù¥ Î™®ÎìàÏùÄ DuRiÍ∞Ä ÏΩîÎìúÎ•º Ïù¥Ìï¥ÌïòÍ≥†, Î¶¨Ìå©ÌÜ†ÎßÅÌïòÎ©∞, Î™©Ï†Å Í∏∞Î∞òÏúºÎ°ú ÏûêÎèô Íµ¨Ï°∞Î•º ÏµúÏ†ÅÌôîÌïòÎäî Î©îÏª§ÎãàÏ¶òÏûÖÎãàÎã§.

Ï£ºÏöî Í∏∞Îä•:
- ÏΩîÎìú ÌååÏã± Î∞è ÏùòÎØ∏ Íµ¨Ï°∞ Ïù¥Ìï¥
- Î™©Ìëú Í∏∞Î∞ò Íµ¨Ï°∞ Î¶¨Ìå©ÌÜ†ÎßÅ
- Í≤ÄÏ¶ù ÌõÑ Ï†ÅÏö©
- AST Í∏∞Î∞ò ÏΩîÎìú Î∂ÑÏÑù Î∞è Î≥ÄÌôò
"""

import asyncio
import ast
import json
import logging
import os
import re
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Union
import difflib

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class RefactorType(Enum):
    """Î¶¨Ìå©ÌÜ†ÎßÅ Ïú†Ìòï Ïó¥Í±∞Ìòï"""
    FUNCTION_EXTRACTION = "function_extraction"
    CLASS_REORGANIZATION = "class_reorganization"
    VARIABLE_RENAMING = "variable_renaming"
    CODE_SIMPLIFICATION = "code_simplification"
    PERFORMANCE_OPTIMIZATION = "performance_optimization"
    STRUCTURE_REORGANIZATION = "structure_reorganization"


class CodeQuality(Enum):
    """ÏΩîÎìú ÌíàÏßà Ïó¥Í±∞Ìòï"""
    EXCELLENT = "excellent"
    GOOD = "good"
    FAIR = "fair"
    POOR = "poor"
    CRITICAL = "critical"


@dataclass
class CodeAnalysis:
    """ÏΩîÎìú Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    module_path: str
    ast_tree: Optional[ast.AST] = None
    functions: List[Dict[str, Any]] = field(default_factory=list)
    classes: List[Dict[str, Any]] = field(default_factory=list)
    variables: List[Dict[str, Any]] = field(default_factory=list)
    imports: List[Dict[str, Any]] = field(default_factory=list)
    complexity_score: float = 0.0
    maintainability_score: float = 0.0
    performance_score: float = 0.0
    quality_issues: List[str] = field(default_factory=list)
    analysis_time: datetime = field(default_factory=datetime.now)


@dataclass
class RefactorProposal:
    """Î¶¨Ìå©ÌÜ†ÎßÅ Ï†úÏïà Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    proposal_id: str
    refactor_type: RefactorType
    target_file: str
    current_code: str
    proposed_code: str
    improvement_description: str
    expected_impact: float
    risk_level: float
    affected_lines: List[int] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class RefactorResult:
    """Î¶¨Ìå©ÌÜ†ÎßÅ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    success: bool
    original_file: str
    new_file: str
    changes_made: List[str]
    quality_improvement: float
    execution_time: float
    error_message: Optional[str] = None


class MetaCoder:
    """ÏΩîÎìú Ïù¥Ìï¥ Î∞è ÏûêÍ∞Ä Î¶¨Ìå©ÌÜ†ÎßÅ Î™®Îìà"""
    
    def __init__(self):
        """Ï¥àÍ∏∞Ìôî"""
        self.analysis_cache: Dict[str, CodeAnalysis] = {}
        self.refactor_history: List[RefactorResult] = []
        self.backup_directory = "backups/meta_coder"
        
        # Î∞±ÏóÖ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        os.makedirs(self.backup_directory, exist_ok=True)
        
        logger.info("MetaCoder Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    async def parse_module(self, module_path: str) -> CodeAnalysis:
        """ÏΩîÎìú ÌååÏã± Î∞è ÏùòÎØ∏ Íµ¨Ï°∞ Ïù¥Ìï¥"""
        try:
            logger.info(f"üîç Î™®Îìà ÌååÏã± ÏãúÏûë: {module_path}")
            
            if not os.path.exists(module_path):
                raise FileNotFoundError(f"Î™®ÎìàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {module_path}")
            
            # ÏΩîÎìú ÏùΩÍ∏∞
            with open(module_path, 'r', encoding='utf-8') as f:
                code_content = f.read()
            
            # AST ÌååÏã±
            tree = ast.parse(code_content)
            
            # ÏΩîÎìú Î∂ÑÏÑù
            analysis = await self._analyze_code_structure(tree, module_path, code_content)
            
            # Ï∫êÏãúÏóê Ï†ÄÏû•
            self.analysis_cache[module_path] = analysis
            
            logger.info(f"‚úÖ Î™®Îìà ÌååÏã± ÏôÑÎ£å: {len(analysis.functions)}Í∞ú Ìï®Ïàò, {len(analysis.classes)}Í∞ú ÌÅ¥ÎûòÏä§")
            
            return analysis
            
        except Exception as e:
            logger.error(f"Î™®Îìà ÌååÏã± Ïã§Ìå®: {e}")
            return await self._create_default_analysis(module_path)
    
    async def refactor_code(self, ast_tree: ast.AST, goal: str) -> RefactorProposal:
        """Î™©Ìëú Í∏∞Î∞ò Íµ¨Ï°∞ Î¶¨Ìå©ÌÜ†ÎßÅ"""
        try:
            logger.info(f"üéØ Î¶¨Ìå©ÌÜ†ÎßÅ ÏãúÏûë: Î™©Ìëú={goal}")
            
            # Î™©ÌëúÏóê Îî∞Î•∏ Î¶¨Ìå©ÌÜ†ÎßÅ Ïú†Ìòï Í≤∞Ï†ï
            refactor_type = await self._determine_refactor_type(goal)
            
            # ÌòÑÏû¨ ÏΩîÎìú Íµ¨Ï°∞ Î∂ÑÏÑù
            current_code = await self._ast_to_code(ast_tree)
            
            # Î¶¨Ìå©ÌÜ†ÎßÅ Ï†ÅÏö©
            refactored_code = await self._apply_refactoring(current_code, refactor_type, goal)
            
            # Í∞úÏÑ† ÏÑ§Î™Ö ÏÉùÏÑ±
            improvement_description = await self._generate_improvement_description(refactor_type, goal)
            
            # ÏòàÏÉÅ ÏòÅÌñ•ÎèÑ Í≥ÑÏÇ∞
            expected_impact = await self._calculate_expected_impact(refactor_type, goal)
            
            # ÏúÑÌóò ÏàòÏ§Ä Í≥ÑÏÇ∞
            risk_level = await self._calculate_risk_level(refactor_type, refactored_code)
            
            # ÏòÅÌñ•Î∞õÎäî ÎùºÏù∏ ÏãùÎ≥Ñ
            affected_lines = await self._identify_affected_lines(current_code, refactored_code)
            
            proposal = RefactorProposal(
                proposal_id=f"refactor_{int(time.time() * 1000)}",
                refactor_type=refactor_type,
                target_file="",  # Ïã§Ï†ú ÌååÏùº Í≤ΩÎ°úÎäî ÎÇòÏ§ëÏóê ÏÑ§Ï†ï
                current_code=current_code,
                proposed_code=refactored_code,
                improvement_description=improvement_description,
                expected_impact=expected_impact,
                risk_level=risk_level,
                affected_lines=affected_lines
            )
            
            logger.info(f"‚úÖ Î¶¨Ìå©ÌÜ†ÎßÅ Ï†úÏïà ÏôÑÎ£å: Ïú†Ìòï={refactor_type.value}, ÏòÅÌñ•ÎèÑ={expected_impact:.2f}")
            
            return proposal
            
        except Exception as e:
            logger.error(f"Î¶¨Ìå©ÌÜ†ÎßÅ Ïã§Ìå®: {e}")
            return await self._create_default_proposal(ast_tree, goal)
    
    async def validate_and_apply(self, new_code: str, test_suite: List[str]) -> RefactorResult:
        """Í≤ÄÏ¶ù ÌõÑ Ï†ÅÏö©"""
        try:
            logger.info("üîç ÏΩîÎìú Í≤ÄÏ¶ù Î∞è Ï†ÅÏö© ÏãúÏûë")
            start_time = time.time()
            
            # Î¨∏Î≤ï Í≤ÄÏ¶ù
            try:
                ast.parse(new_code)
            except SyntaxError as e:
                return RefactorResult(
                    success=False,
                    original_file="",
                    new_file="",
                    changes_made=[],
                    quality_improvement=0.0,
                    execution_time=time.time() - start_time,
                    error_message=f"Î¨∏Î≤ï Ïò§Î•ò: {e}"
                )
            
            # ÌÖåÏä§Ìä∏ Ïã§Ìñâ (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
            test_results = await self._run_tests(new_code, test_suite)
            
            if test_results.get('success', False):
                # ÌíàÏßà Í∞úÏÑ†ÎèÑ Í≥ÑÏÇ∞
                quality_improvement = await self._calculate_quality_improvement(new_code)
                
                # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù
                changes_made = await self._record_changes(new_code)
                
                result = RefactorResult(
                    success=True,
                    original_file="",  # Ïã§Ï†ú ÌååÏùº Í≤ΩÎ°úÎäî ÎÇòÏ§ëÏóê ÏÑ§Ï†ï
                    new_file="",
                    changes_made=changes_made,
                    quality_improvement=quality_improvement,
                    execution_time=time.time() - start_time
                )
                
                logger.info(f"‚úÖ ÏΩîÎìú Í≤ÄÏ¶ù Î∞è Ï†ÅÏö© ÏôÑÎ£å: ÌíàÏßà Í∞úÏÑ†ÎèÑ={quality_improvement:.2f}")
                
            else:
                result = RefactorResult(
                    success=False,
                    original_file="",
                    new_file="",
                    changes_made=[],
                    quality_improvement=0.0,
                    execution_time=time.time() - start_time,
                    error_message="ÌÖåÏä§Ìä∏ Ïã§Ìå®"
                )
                
                logger.warning("‚ö†Ô∏è ÏΩîÎìú Í≤ÄÏ¶ù Ïã§Ìå®: ÌÖåÏä§Ìä∏ Ïã§Ìå®")
            
            # Í≤∞Í≥º Í∏∞Î°ù
            self.refactor_history.append(result)
            
            return result
            
        except Exception as e:
            logger.error(f"ÏΩîÎìú Í≤ÄÏ¶ù Î∞è Ï†ÅÏö© Ïã§Ìå®: {e}")
            return RefactorResult(
                success=False,
                original_file="",
                new_file="",
                changes_made=[],
                quality_improvement=0.0,
                execution_time=0.0,
                error_message=str(e)
            )
    
    async def _analyze_code_structure(self, tree: ast.AST, module_path: str, code_content: str) -> CodeAnalysis:
        """ÏΩîÎìú Íµ¨Ï°∞ Î∂ÑÏÑù"""
        try:
            analysis = CodeAnalysis(module_path=module_path, ast_tree=tree)
            
            # Ìï®Ïàò Î∂ÑÏÑù
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    func_info = {
                        'name': node.name,
                        'line_number': node.lineno,
                        'args_count': len(node.args.args),
                        'body_lines': len(node.body),
                        'has_docstring': ast.get_docstring(node) is not None
                    }
                    analysis.functions.append(func_info)
                
                elif isinstance(node, ast.ClassDef):
                    class_info = {
                        'name': node.name,
                        'line_number': node.lineno,
                        'methods_count': len([n for n in node.body if isinstance(n, ast.FunctionDef)]),
                        'has_docstring': ast.get_docstring(node) is not None
                    }
                    analysis.classes.append(class_info)
                
                elif isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):
                    import_info = {
                        'type': 'import' if isinstance(node, ast.Import) else 'from',
                        'line_number': node.lineno,
                        'names': [alias.name for alias in node.names]
                    }
                    analysis.imports.append(import_info)
            
            # ÌíàÏßà Ï†êÏàò Í≥ÑÏÇ∞
            analysis.complexity_score = await self._calculate_complexity_score(tree)
            analysis.maintainability_score = await self._calculate_maintainability_score(tree)
            analysis.performance_score = await self._calculate_performance_score(tree)
            
            # ÌíàÏßà Ïù¥Ïäà ÏãùÎ≥Ñ
            analysis.quality_issues = await self._identify_quality_issues(tree, code_content)
            
            return analysis
            
        except Exception as e:
            logger.error(f"ÏΩîÎìú Íµ¨Ï°∞ Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return await self._create_default_analysis(module_path)
    
    async def _determine_refactor_type(self, goal: str) -> RefactorType:
        """Î¶¨Ìå©ÌÜ†ÎßÅ Ïú†Ìòï Í≤∞Ï†ï"""
        goal_lower = goal.lower()
        
        if 'ÏÑ±Îä•' in goal_lower or 'performance' in goal_lower:
            return RefactorType.PERFORMANCE_OPTIMIZATION
        elif 'Ìï®Ïàò' in goal_lower or 'function' in goal_lower:
            return RefactorType.FUNCTION_EXTRACTION
        elif 'ÌÅ¥ÎûòÏä§' in goal_lower or 'class' in goal_lower:
            return RefactorType.CLASS_REORGANIZATION
        elif 'Î≥ÄÏàò' in goal_lower or 'variable' in goal_lower:
            return RefactorType.VARIABLE_RENAMING
        elif 'Íµ¨Ï°∞' in goal_lower or 'structure' in goal_lower:
            return RefactorType.STRUCTURE_REORGANIZATION
        else:
            return RefactorType.CODE_SIMPLIFICATION
    
    async def _apply_refactoring(self, current_code: str, refactor_type: RefactorType, goal: str) -> str:
        """Î¶¨Ìå©ÌÜ†ÎßÅ Ï†ÅÏö©"""
        try:
            refactored_code = current_code
            
            if refactor_type == RefactorType.FUNCTION_EXTRACTION:
                refactored_code = await self._extract_functions(refactored_code)
            elif refactor_type == RefactorType.PERFORMANCE_OPTIMIZATION:
                refactored_code = await self._optimize_performance(refactored_code)
            elif refactor_type == RefactorType.CODE_SIMPLIFICATION:
                refactored_code = await self._simplify_code(refactored_code)
            elif refactor_type == RefactorType.STRUCTURE_REORGANIZATION:
                refactored_code = await self._reorganize_structure(refactored_code)
            
            return refactored_code
            
        except Exception as e:
            logger.error(f"Î¶¨Ìå©ÌÜ†ÎßÅ Ï†ÅÏö© Ïã§Ìå®: {e}")
            return current_code
    
    async def _extract_functions(self, code: str) -> str:
        """Ìï®Ïàò Ï∂îÏ∂ú"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Î≥µÏû°Ìïú Î°úÏßÅÏùÑ Ìï®ÏàòÎ°ú Ï∂îÏ∂úÌïòÎäî Î°úÏßÅ
        return code
    
    async def _optimize_performance(self, code: str) -> str:
        """ÏÑ±Îä• ÏµúÏ†ÅÌôî"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏÑ±Îä• ÏµúÏ†ÅÌôî Î°úÏßÅ
        return code
    
    async def _simplify_code(self, code: str) -> str:
        """ÏΩîÎìú Îã®ÏàúÌôî"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏΩîÎìú Îã®ÏàúÌôî Î°úÏßÅ
        return code
    
    async def _reorganize_structure(self, code: str) -> str:
        """Íµ¨Ï°∞ Ïû¨Íµ¨ÏÑ±"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Íµ¨Ï°∞ Ïû¨Íµ¨ÏÑ± Î°úÏßÅ
        return code
    
    async def _generate_improvement_description(self, refactor_type: RefactorType, goal: str) -> str:
        """Í∞úÏÑ† ÏÑ§Î™Ö ÏÉùÏÑ±"""
        descriptions = {
            RefactorType.FUNCTION_EXTRACTION: "Ìï®Ïàò Ï∂îÏ∂úÏùÑ ÌÜµÌïú ÏΩîÎìú Î™®ÎìàÌôî",
            RefactorType.CLASS_REORGANIZATION: "ÌÅ¥ÎûòÏä§ Ïû¨Íµ¨ÏÑ±ÏùÑ ÌÜµÌïú Íµ¨Ï°∞ Í∞úÏÑ†",
            RefactorType.VARIABLE_RENAMING: "Î≥ÄÏàòÎ™Ö Í∞úÏÑ†ÏùÑ ÌÜµÌïú Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ",
            RefactorType.CODE_SIMPLIFICATION: "ÏΩîÎìú Îã®ÏàúÌôîÎ•º ÌÜµÌïú Ïù¥Ìï¥ÎèÑ Ìñ•ÏÉÅ",
            RefactorType.PERFORMANCE_OPTIMIZATION: "ÏÑ±Îä• ÏµúÏ†ÅÌôîÎ•º ÌÜµÌïú Ïã§Ìñâ ÏÜçÎèÑ Ìñ•ÏÉÅ",
            RefactorType.STRUCTURE_REORGANIZATION: "Íµ¨Ï°∞ Ïû¨Íµ¨ÏÑ±ÏùÑ ÌÜµÌïú Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ìñ•ÏÉÅ"
        }
        
        return descriptions.get(refactor_type, f"Î™©Ìëú '{goal}'Ïóê Îî∞Î•∏ ÏΩîÎìú Í∞úÏÑ†")
    
    async def _calculate_expected_impact(self, refactor_type: RefactorType, goal: str) -> float:
        """ÏòàÏÉÅ ÏòÅÌñ•ÎèÑ Í≥ÑÏÇ∞"""
        base_impact = 0.5
        
        if refactor_type == RefactorType.PERFORMANCE_OPTIMIZATION:
            base_impact = 0.8
        elif refactor_type == RefactorType.STRUCTURE_REORGANIZATION:
            base_impact = 0.7
        elif refactor_type == RefactorType.FUNCTION_EXTRACTION:
            base_impact = 0.6
        
        return min(1.0, max(0.0, base_impact))
    
    async def _calculate_risk_level(self, refactor_type: RefactorType, refactored_code: str) -> float:
        """ÏúÑÌóò ÏàòÏ§Ä Í≥ÑÏÇ∞"""
        base_risk = 0.3
        
        if refactor_type == RefactorType.STRUCTURE_REORGANIZATION:
            base_risk = 0.7
        elif refactor_type == RefactorType.CLASS_REORGANIZATION:
            base_risk = 0.6
        elif refactor_type == RefactorType.PERFORMANCE_OPTIMIZATION:
            base_risk = 0.5
        
        return min(1.0, max(0.0, base_risk))
    
    async def _identify_affected_lines(self, current_code: str, refactored_code: str) -> List[int]:
        """ÏòÅÌñ•Î∞õÎäî ÎùºÏù∏ ÏãùÎ≥Ñ"""
        try:
            current_lines = current_code.split('\n')
            refactored_lines = refactored_code.split('\n')
            
            affected_lines = []
            
            # Í∞ÑÎã®Ìïú ÎùºÏù∏ ÎπÑÍµê (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Îçî Ï†ïÍµêÌïú diff ÏïåÍ≥†Î¶¨Ï¶ò ÏÇ¨Ïö©)
            for i, (current, refactored) in enumerate(zip(current_lines, refactored_lines)):
                if current.strip() != refactored.strip():
                    affected_lines.append(i + 1)
            
            return affected_lines
            
        except Exception as e:
            logger.error(f"ÏòÅÌñ•Î∞õÎäî ÎùºÏù∏ ÏãùÎ≥Ñ Ïã§Ìå®: {e}")
            return []
    
    async def _ast_to_code(self, tree: ast.AST) -> str:
        """ASTÎ•º ÏΩîÎìúÎ°ú Î≥ÄÌôò"""
        try:
            # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ast.unparse ÏÇ¨Ïö© (Python 3.9+)
            # Ïó¨Í∏∞ÏÑúÎäî Í∞ÑÎã®Ìïú ÏãúÎÆ¨Î†àÏù¥ÏÖò
            return "# ASTÏóêÏÑú Î≥ÄÌôòÎêú ÏΩîÎìú\n"
            
        except Exception as e:
            logger.error(f"ASTÎ•º ÏΩîÎìúÎ°ú Î≥ÄÌôò Ïã§Ìå®: {e}")
            return ""
    
    async def _run_tests(self, new_code: str, test_suite: List[str]) -> Dict[str, Any]:
        """ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
        try:
            # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÌÖåÏä§Ìä∏ Ïä§ÏúÑÌä∏ Ïã§Ìñâ
            # Ïó¨Í∏∞ÏÑúÎäî ÏãúÎÆ¨Î†àÏù¥ÏÖò
            test_results = {
                'success': True,
                'tests_run': len(test_suite),
                'tests_passed': len(test_suite),
                'tests_failed': 0,
                'coverage': 0.85
            }
            
            return test_results
            
        except Exception as e:
            logger.error(f"ÌÖåÏä§Ìä∏ Ïã§Ìñâ Ïã§Ìå®: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _calculate_quality_improvement(self, new_code: str) -> float:
        """ÌíàÏßà Í∞úÏÑ†ÎèÑ Í≥ÑÏÇ∞"""
        try:
            # Í∞ÑÎã®Ìïú ÌíàÏßà Í∞úÏÑ†ÎèÑ Í≥ÑÏÇ∞ (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Îçî Ï†ïÍµêÌïú Î©îÌä∏Î¶≠ ÏÇ¨Ïö©)
            quality_score = 0.5  # Í∏∞Î≥∏ Ï†êÏàò
            
            # ÏΩîÎìú Í∏∏Ïù¥ Í∏∞Î∞ò Ï†êÏàò
            lines = len(new_code.split('\n'))
            if 10 <= lines <= 100:
                quality_score += 0.2
            elif lines < 10:
                quality_score += 0.1
            
            # Ï£ºÏÑù ÎπÑÏú® Í∏∞Î∞ò Ï†êÏàò
            comment_lines = len([line for line in new_code.split('\n') if line.strip().startswith('#')])
            comment_ratio = comment_lines / max(lines, 1)
            if 0.1 <= comment_ratio <= 0.3:
                quality_score += 0.2
            
            return min(1.0, quality_score)
            
        except Exception as e:
            logger.error(f"ÌíàÏßà Í∞úÏÑ†ÎèÑ Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.0
    
    async def _record_changes(self, new_code: str) -> List[str]:
        """Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù"""
        try:
            # Í∞ÑÎã®Ìïú Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Îçî Ï†ïÍµêÌïú diff ÏÇ¨Ïö©)
            changes = []
            
            lines = new_code.split('\n')
            for i, line in enumerate(lines):
                if line.strip() and not line.strip().startswith('#'):
                    changes.append(f"ÎùºÏù∏ {i+1}: {line.strip()[:50]}...")
            
            return changes[:10]  # ÏµúÎåÄ 10Í∞úÎßå Î∞òÌôò
            
        except Exception as e:
            logger.error(f"Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù Ïã§Ìå®: {e}")
            return ["Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù Ïã§Ìå®"]
    
    async def _calculate_complexity_score(self, tree: ast.AST) -> float:
        """Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            complexity_metrics = {
                'functions': 0,
                'classes': 0,
                'nested_levels': 0
            }
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    complexity_metrics['functions'] += 1
                elif isinstance(node, ast.ClassDef):
                    complexity_metrics['classes'] += 1
                elif isinstance(node, ast.If) or isinstance(node, ast.For) or isinstance(node, ast.While):
                    complexity_metrics['nested_levels'] += 1
            
            # Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞ (0-1, ÎÇÆÏùÑÏàòÎ°ù Ï¢ãÏùå)
            complexity_score = min(1.0, (
                complexity_metrics['functions'] * 0.1 +
                complexity_metrics['classes'] * 0.2 +
                complexity_metrics['nested_levels'] * 0.3
            ) / 10.0)
            
            return complexity_score
            
        except Exception as e:
            logger.error(f"Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.5
    
    async def _calculate_maintainability_score(self, tree: ast.AST) -> float:
        """Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            maintainability_issues = 0
            
            for node in ast.walk(tree):
                # Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ïù¥Ïäà Ìå®ÌÑ¥ Í≤ÄÏÇ¨
                if isinstance(node, ast.FunctionDef) and len(node.args.args) > 5:
                    maintainability_issues += 1
                elif isinstance(node, ast.ClassDef) and len(node.body) > 20:
                    maintainability_issues += 1
            
            # Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞ (0-1, ÎÜíÏùÑÏàòÎ°ù Ï¢ãÏùå)
            maintainability_score = max(0.0, 1.0 - (maintainability_issues * 0.1))
            
            return maintainability_score
            
        except Exception as e:
            logger.error(f"Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.8
    
    async def _calculate_performance_score(self, tree: ast.AST) -> float:
        """ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            performance_issues = 0
            
            for node in ast.walk(tree):
                # ÏÑ±Îä• Ïù¥Ïäà Ìå®ÌÑ¥ Í≤ÄÏÇ¨
                if isinstance(node, ast.ListComp) and len(node.generators) > 1:
                    performance_issues += 1
                elif isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                    if node.func.id in ['eval', 'exec']:
                        performance_issues += 2
            
            # ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞ (0-1, ÎÜíÏùÑÏàòÎ°ù Ï¢ãÏùå)
            performance_score = max(0.0, 1.0 - (performance_issues * 0.1))
            
            return performance_score
            
        except Exception as e:
            logger.error(f"ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.7
    
    async def _identify_quality_issues(self, tree: ast.AST, code_content: str) -> List[str]:
        """ÌíàÏßà Ïù¥Ïäà ÏãùÎ≥Ñ"""
        issues = []
        
        try:
            # Î≥µÏû°Ìïú Ìï®Ïàò ÏãùÎ≥Ñ
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef) and len(node.body) > 10:
                    issues.append(f"Ìï®Ïàò '{node.name}'Ïù¥ ÎÑàÎ¨¥ Î≥µÏû°Ìï® (ÎùºÏù∏ Ïàò: {len(node.body)})")
            
            # Ï§ëÎ≥µ ÏΩîÎìú ÏãùÎ≥Ñ
            if code_content.count("def ") > 10:
                issues.append("Ï§ëÎ≥µ ÏΩîÎìúÍ∞Ä ÎßéÏùå")
            
            # ÏÑ±Îä• Ïù¥Ïäà ÏãùÎ≥Ñ
            if "for " in code_content and "in " in code_content:
                issues.append("Î∞òÎ≥µÎ¨∏ ÏµúÏ†ÅÌôî ÌïÑÏöî")
            
        except Exception as e:
            logger.error(f"ÌíàÏßà Ïù¥Ïäà ÏãùÎ≥Ñ Ïã§Ìå®: {e}")
        
        return issues
    
    async def _create_default_analysis(self, module_path: str) -> CodeAnalysis:
        """Í∏∞Î≥∏ Î∂ÑÏÑù ÏÉùÏÑ±"""
        return CodeAnalysis(
            module_path=module_path,
            complexity_score=0.5,
            maintainability_score=0.8,
            performance_score=0.7,
            quality_issues=[]
        )
    
    async def _create_default_proposal(self, ast_tree: ast.AST, goal: str) -> RefactorProposal:
        """Í∏∞Î≥∏ Ï†úÏïà ÏÉùÏÑ±"""
        return RefactorProposal(
            proposal_id=f"default_refactor_{int(time.time() * 1000)}",
            refactor_type=RefactorType.CODE_SIMPLIFICATION,
            target_file="",
            current_code="",
            proposed_code="",
            improvement_description=f"Î™©Ìëú '{goal}'Ïóê Îî∞Î•∏ Í∏∞Î≥∏ Í∞úÏÑ†",
            expected_impact=0.1,
            risk_level=0.1,
            affected_lines=[]
        )


async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    # MetaCoder Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
    meta_coder = MetaCoder()
    
    # ÌÖåÏä§Ìä∏Ïö© Î™®Îìà Í≤ΩÎ°ú
    test_module = "DuRiCore/duri_thought_flow.py"
    
    # Î™®Îìà ÌååÏã±
    analysis = await meta_coder.parse_module(test_module)
    
    # Î¶¨Ìå©ÌÜ†ÎßÅ Ï†úÏïà
    if analysis.ast_tree:
        proposal = await meta_coder.refactor_code(analysis.ast_tree, "ÏÑ±Îä• ÏµúÏ†ÅÌôî")
        
        # Í≤ÄÏ¶ù Î∞è Ï†ÅÏö©
        test_suite = ["test_basic_functionality", "test_performance"]
        result = await meta_coder.validate_and_apply(proposal.proposed_code, test_suite)
        
        # Í≤∞Í≥º Ï∂úÎ†•
        print("\n" + "="*80)
        print("ü§ñ MetaCoder Engine ÌÖåÏä§Ìä∏ Í≤∞Í≥º")
        print("="*80)
        
        print(f"\nüìä ÏΩîÎìú Î∂ÑÏÑù:")
        print(f"  - Ìï®Ïàò Ïàò: {len(analysis.functions)}")
        print(f"  - ÌÅ¥ÎûòÏä§ Ïàò: {len(analysis.classes)}")
        print(f"  - Î≥µÏû°ÎèÑ Ï†êÏàò: {analysis.complexity_score:.2f}")
        print(f"  - Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò: {analysis.maintainability_score:.2f}")
        print(f"  - ÏÑ±Îä• Ï†êÏàò: {analysis.performance_score:.2f}")
        
        print(f"\nüéØ Î¶¨Ìå©ÌÜ†ÎßÅ Ï†úÏïà:")
        print(f"  - Î¶¨Ìå©ÌÜ†ÎßÅ Ïú†Ìòï: {proposal.refactor_type.value}")
        print(f"  - ÏòàÏÉÅ ÏòÅÌñ•ÎèÑ: {proposal.expected_impact:.2f}")
        print(f"  - ÏúÑÌóò ÏàòÏ§Ä: {proposal.risk_level:.2f}")
        print(f"  - Í∞úÏÑ† ÏÑ§Î™Ö: {proposal.improvement_description}")
        
        print(f"\n‚úÖ Í≤ÄÏ¶ù Í≤∞Í≥º:")
        print(f"  - ÏÑ±Í≥µ Ïó¨Î∂Ä: {result.success}")
        print(f"  - ÌíàÏßà Í∞úÏÑ†ÎèÑ: {result.quality_improvement:.2f}")
        print(f"  - Ïã§Ìñâ ÏãúÍ∞Ñ: {result.execution_time:.2f}Ï¥à")
        
        if result.error_message:
            print(f"  - Ïò§Î•ò Î©îÏãúÏßÄ: {result.error_message}")
    
    return analysis


if __name__ == "__main__":
    asyncio.run(main()) 