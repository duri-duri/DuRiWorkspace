#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DuRi Phase Œ©: Self-Rewriting Module

Ïù¥ Î™®ÎìàÏùÄ DuRiÍ∞Ä ÏûêÍ∏∞ ÏûêÏã†Ïùò ÏÇ¨Í≥† Î£®Ìã¥Í≥º Íµ¨Ï°∞Î•º Í¥ÄÏ∞∞ÌïòÍ≥† ÏàòÏ†ïÌïòÎäî Î©îÏª§ÎãàÏ¶òÏûÖÎãàÎã§.
Î∞òÏÑ± Ï†êÏàòÍ∞Ä ÎÇÆÏùÑ Îïå ÏûêÎèôÏúºÎ°ú ÏΩîÎìúÎ•º Í∞úÏÑ†ÌïòÍ≥† ÏàòÏ†ïÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.

Ï£ºÏöî Í∏∞Îä•:
- ÏûêÏã†Ïùò ÏΩîÎìú ÌèâÍ∞Ä
- Í∞úÏÑ†Îêú Î°úÏßÅ Ï†úÏïà
- ÏïàÏ†ÑÌïú ÏûêÍ∞Ä ÏàòÏ†ï Ïã§Ìñâ
- ÌÖåÏä§Ìä∏ Í∏∞Î∞ò rollback Î≥¥Ìò∏
"""

import asyncio
import ast
import json
import logging
import os
import shutil
import tempfile
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Union
import difflib

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class RewriteType(Enum):
    """Ïû¨ÏûëÏÑ± Ïú†Ìòï Ïó¥Í±∞Ìòï"""
    LOGIC_IMPROVEMENT = "logic_improvement"
    PERFORMANCE_OPTIMIZATION = "performance_optimization"
    CODE_CLEANUP = "code_cleanup"
    BUG_FIX = "bug_fix"
    STRUCTURE_REORGANIZATION = "structure_reorganization"


class RewriteStatus(Enum):
    """Ïû¨ÏûëÏÑ± ÏÉÅÌÉú Ïó¥Í±∞Ìòï"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"


@dataclass
class CodeAssessment:
    """ÏΩîÎìú ÌèâÍ∞Ä Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    module_path: str
    complexity_score: float
    performance_score: float
    maintainability_score: float
    bug_potential: float
    improvement_opportunities: List[str] = field(default_factory=list)
    assessment_time: datetime = field(default_factory=datetime.now)


@dataclass
class RewriteProposal:
    """Ïû¨ÏûëÏÑ± Ï†úÏïà Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    proposal_id: str
    rewrite_type: RewriteType
    target_file: str
    current_code: str
    proposed_code: str
    improvement_description: str
    expected_impact: float
    risk_level: float
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class RewriteResult:
    """Ïû¨ÏûëÏÑ± Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    success: bool
    original_file: str
    backup_file: str
    new_file: str
    changes_made: List[str]
    test_results: Dict[str, Any]
    execution_time: float
    status: RewriteStatus
    error_message: Optional[str] = None


class SelfRewritingModule:
    """ÏûêÍ∏∞ ÏûêÏã†Ïùò ÏΩîÎìúÎ•º Ïû¨ÏûëÏÑ±ÌïòÎäî Î™®Îìà"""
    
    def __init__(self):
        """Ï¥àÍ∏∞Ìôî"""
        self.rewrite_history: List[RewriteResult] = []
        self.backup_directory = "backups/self_rewrites"
        self.test_suite_path = "tests/"
        self.max_rewrite_attempts = 3
        self.rewrite_threshold = 0.7
        
        # Î∞±ÏóÖ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
        os.makedirs(self.backup_directory, exist_ok=True)
        
        logger.info("Self-Rewriting Module Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    async def assess_self_code(self, module_path: str) -> CodeAssessment:
        """ÏûêÏã†Ïùò ÏΩîÎìú ÌèâÍ∞Ä"""
        try:
            logger.info(f"üîç ÏΩîÎìú ÌèâÍ∞Ä ÏãúÏûë: {module_path}")
            
            if not os.path.exists(module_path):
                raise FileNotFoundError(f"Î™®ÎìàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {module_path}")
            
            # ÏΩîÎìú ÏùΩÍ∏∞
            with open(module_path, 'r', encoding='utf-8') as f:
                code_content = f.read()
            
            # AST ÌååÏã±
            tree = ast.parse(code_content)
            
            # Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞
            complexity_score = await self._calculate_complexity_score(tree)
            
            # ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞
            performance_score = await self._calculate_performance_score(tree)
            
            # Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞
            maintainability_score = await self._calculate_maintainability_score(tree)
            
            # Î≤ÑÍ∑∏ Ïû†Ïû¨ÏÑ± Í≥ÑÏÇ∞
            bug_potential = await self._calculate_bug_potential(tree)
            
            # Í∞úÏÑ† Í∏∞Ìöå ÏãùÎ≥Ñ
            improvement_opportunities = await self._identify_improvement_opportunities(tree, code_content)
            
            assessment = CodeAssessment(
                module_path=module_path,
                complexity_score=complexity_score,
                performance_score=performance_score,
                maintainability_score=maintainability_score,
                bug_potential=bug_potential,
                improvement_opportunities=improvement_opportunities
            )
            
            logger.info(f"‚úÖ ÏΩîÎìú ÌèâÍ∞Ä ÏôÑÎ£å: Î≥µÏû°ÎèÑ={complexity_score:.2f}, ÏÑ±Îä•={performance_score:.2f}, Ïú†ÏßÄÎ≥¥ÏàòÏÑ±={maintainability_score:.2f}")
            
            return assessment
            
        except Exception as e:
            logger.error(f"ÏΩîÎìú ÌèâÍ∞Ä Ïã§Ìå®: {e}")
            return await self._create_default_assessment(module_path)
    
    async def generate_alternative(self, current_logic: str, assessment: CodeAssessment) -> RewriteProposal:
        """Í∞úÏÑ†Îêú Î°úÏßÅ Ï†úÏïà"""
        try:
            logger.info("üéØ Í∞úÏÑ†Îêú Î°úÏßÅ Ï†úÏïà ÏãúÏûë")
            
            # Ïû¨ÏûëÏÑ± Ïú†Ìòï Í≤∞Ï†ï
            rewrite_type = await self._determine_rewrite_type(assessment)
            
            # Í∞úÏÑ†Îêú ÏΩîÎìú ÏÉùÏÑ±
            proposed_code = await self._generate_improved_code(current_logic, rewrite_type, assessment)
            
            # Í∞úÏÑ† ÏÑ§Î™Ö ÏÉùÏÑ±
            improvement_description = await self._generate_improvement_description(rewrite_type, assessment)
            
            # ÏòàÏÉÅ ÏòÅÌñ•ÎèÑ Í≥ÑÏÇ∞
            expected_impact = await self._calculate_expected_impact(rewrite_type, assessment)
            
            # ÏúÑÌóò ÏàòÏ§Ä Í≥ÑÏÇ∞
            risk_level = await self._calculate_risk_level(rewrite_type, proposed_code)
            
            proposal = RewriteProposal(
                proposal_id=f"proposal_{int(time.time() * 1000)}",
                rewrite_type=rewrite_type,
                target_file=assessment.module_path,
                current_code=current_logic,
                proposed_code=proposed_code,
                improvement_description=improvement_description,
                expected_impact=expected_impact,
                risk_level=risk_level
            )
            
            logger.info(f"‚úÖ Í∞úÏÑ†Îêú Î°úÏßÅ Ï†úÏïà ÏôÑÎ£å: Ïú†Ìòï={rewrite_type.value}, ÏòÅÌñ•ÎèÑ={expected_impact:.2f}")
            
            return proposal
            
        except Exception as e:
            logger.error(f"Í∞úÏÑ†Îêú Î°úÏßÅ Ï†úÏïà Ïã§Ìå®: {e}")
            return await self._create_default_proposal(current_logic, assessment)
    
    async def safely_rewrite(self, target_file: str, new_logic: str) -> RewriteResult:
        """ÌÖåÏä§Ìä∏ ÌõÑ ÏûêÍ∞Ä ÏàòÏ†ï Ïã§Ìñâ"""
        try:
            logger.info(f"üîß ÏïàÏ†ÑÌïú ÏûêÍ∞Ä ÏàòÏ†ï ÏãúÏûë: {target_file}")
            start_time = time.time()
            
            # Î∞±ÏóÖ ÏÉùÏÑ±
            backup_file = await self._create_backup(target_file)
            
            # ÏûÑÏãú ÌååÏùºÏóê ÏÉà ÏΩîÎìú ÏûëÏÑ±
            temp_file = await self._create_temp_file(new_logic)
            
            # ÌÖåÏä§Ìä∏ Ïã§Ìñâ
            test_results = await self._run_tests(temp_file)
            
            if test_results.get('success', False):
                # ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ Ïãú Ïã§Ï†ú ÌååÏùºÏóê Ï†ÅÏö©
                await self._apply_changes(target_file, temp_file)
                
                # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù
                changes_made = await self._record_changes(target_file, backup_file)
                
                result = RewriteResult(
                    success=True,
                    original_file=target_file,
                    backup_file=backup_file,
                    new_file=target_file,
                    changes_made=changes_made,
                    test_results=test_results,
                    execution_time=time.time() - start_time,
                    status=RewriteStatus.COMPLETED
                )
                
                logger.info(f"‚úÖ ÏûêÍ∞Ä ÏàòÏ†ï ÏôÑÎ£å: {len(changes_made)}Í∞ú Î≥ÄÍ≤ΩÏÇ¨Ìï≠")
                
            else:
                # ÌÖåÏä§Ìä∏ Ïã§Ìå® Ïãú Î°§Î∞±
                await self._rollback_changes(target_file, backup_file)
                
                result = RewriteResult(
                    success=False,
                    original_file=target_file,
                    backup_file=backup_file,
                    new_file=target_file,
                    changes_made=[],
                    test_results=test_results,
                    execution_time=time.time() - start_time,
                    status=RewriteStatus.ROLLED_BACK,
                    error_message="ÌÖåÏä§Ìä∏ Ïã§Ìå®Î°ú Ïù∏Ìïú Î°§Î∞±"
                )
                
                logger.warning(f"‚ö†Ô∏è ÏûêÍ∞Ä ÏàòÏ†ï Ïã§Ìå®: ÌÖåÏä§Ìä∏ Ïã§Ìå®Î°ú Î°§Î∞±Îê®")
            
            # Í≤∞Í≥º Í∏∞Î°ù
            self.rewrite_history.append(result)
            
            return result
            
        except Exception as e:
            logger.error(f"ÏïàÏ†ÑÌïú ÏûêÍ∞Ä ÏàòÏ†ï Ïã§Ìå®: {e}")
            return await self._create_failed_result(target_file, str(e))
    
    async def _calculate_complexity_score(self, tree: ast.AST) -> float:
        """Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            complexity_metrics = {
                'functions': 0,
                'classes': 0,
                'nested_levels': 0,
                'lines': 0
            }
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    complexity_metrics['functions'] += 1
                elif isinstance(node, ast.ClassDef):
                    complexity_metrics['classes'] += 1
                elif isinstance(node, ast.If) or isinstance(node, ast.For) or isinstance(node, ast.While):
                    complexity_metrics['nested_levels'] += 1
            
            # Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞ (0-1, ÎÇÆÏùÑÏàòÎ°ù Ï¢ãÏùå)
            complexity_score = min(1.0, (
                complexity_metrics['functions'] * 0.1 +
                complexity_metrics['classes'] * 0.2 +
                complexity_metrics['nested_levels'] * 0.3
            ) / 10.0)
            
            return complexity_score
            
        except Exception as e:
            logger.error(f"Î≥µÏû°ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.5
    
    async def _calculate_performance_score(self, tree: ast.AST) -> float:
        """ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            performance_issues = 0
            
            for node in ast.walk(tree):
                # ÏÑ±Îä• Ïù¥Ïäà Ìå®ÌÑ¥ Í≤ÄÏÇ¨
                if isinstance(node, ast.ListComp) and len(node.generators) > 1:
                    performance_issues += 1
                elif isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                    if node.func.id in ['eval', 'exec']:
                        performance_issues += 2
            
            # ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞ (0-1, ÎÜíÏùÑÏàòÎ°ù Ï¢ãÏùå)
            performance_score = max(0.0, 1.0 - (performance_issues * 0.1))
            
            return performance_score
            
        except Exception as e:
            logger.error(f"ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.7
    
    async def _calculate_maintainability_score(self, tree: ast.AST) -> float:
        """Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞"""
        try:
            maintainability_issues = 0
            
            for node in ast.walk(tree):
                # Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ïù¥Ïäà Ìå®ÌÑ¥ Í≤ÄÏÇ¨
                if isinstance(node, ast.FunctionDef) and len(node.args.args) > 5:
                    maintainability_issues += 1
                elif isinstance(node, ast.ClassDef) and len(node.body) > 20:
                    maintainability_issues += 1
            
            # Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞ (0-1, ÎÜíÏùÑÏàòÎ°ù Ï¢ãÏùå)
            maintainability_score = max(0.0, 1.0 - (maintainability_issues * 0.1))
            
            return maintainability_score
            
        except Exception as e:
            logger.error(f"Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.8
    
    async def _calculate_bug_potential(self, tree: ast.AST) -> float:
        """Î≤ÑÍ∑∏ Ïû†Ïû¨ÏÑ± Í≥ÑÏÇ∞"""
        try:
            bug_indicators = 0
            
            for node in ast.walk(tree):
                # Î≤ÑÍ∑∏ Ïû†Ïû¨ÏÑ± Ìå®ÌÑ¥ Í≤ÄÏÇ¨
                if isinstance(node, ast.Compare) and len(node.ops) > 1:
                    bug_indicators += 1
                elif isinstance(node, ast.ExceptHandler) and node.type is None:
                    bug_indicators += 1
            
            # Î≤ÑÍ∑∏ Ïû†Ïû¨ÏÑ± Í≥ÑÏÇ∞ (0-1, ÎÇÆÏùÑÏàòÎ°ù Ï¢ãÏùå)
            bug_potential = min(1.0, bug_indicators * 0.2)
            
            return bug_potential
            
        except Exception as e:
            logger.error(f"Î≤ÑÍ∑∏ Ïû†Ïû¨ÏÑ± Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
            return 0.3
    
    async def _identify_improvement_opportunities(self, tree: ast.AST, code_content: str) -> List[str]:
        """Í∞úÏÑ† Í∏∞Ìöå ÏãùÎ≥Ñ"""
        opportunities = []
        
        try:
            # Î≥µÏû°Ìïú Ìï®Ïàò ÏãùÎ≥Ñ
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef) and len(node.body) > 10:
                    opportunities.append(f"Ìï®Ïàò '{node.name}' Î¶¨Ìå©ÌÜ†ÎßÅ ÌïÑÏöî (ÎÑàÎ¨¥ Î≥µÏû°Ìï®)")
            
            # Ï§ëÎ≥µ ÏΩîÎìú ÏãùÎ≥Ñ
            if code_content.count("def ") > 10:
                opportunities.append("Ï§ëÎ≥µ ÏΩîÎìú Ï†úÍ±∞ ÌïÑÏöî")
            
            # ÏÑ±Îä• ÏµúÏ†ÅÌôî Í∏∞Ìöå ÏãùÎ≥Ñ
            if "for " in code_content and "in " in code_content:
                opportunities.append("Î∞òÎ≥µÎ¨∏ ÏµúÏ†ÅÌôî Í∏∞Ìöå")
            
        except Exception as e:
            logger.error(f"Í∞úÏÑ† Í∏∞Ìöå ÏãùÎ≥Ñ Ïã§Ìå®: {e}")
        
        return opportunities
    
    async def _determine_rewrite_type(self, assessment: CodeAssessment) -> RewriteType:
        """Ïû¨ÏûëÏÑ± Ïú†Ìòï Í≤∞Ï†ï"""
        if assessment.complexity_score > 0.7:
            return RewriteType.STRUCTURE_REORGANIZATION
        elif assessment.performance_score < 0.6:
            return RewriteType.PERFORMANCE_OPTIMIZATION
        elif assessment.bug_potential > 0.5:
            return RewriteType.BUG_FIX
        elif assessment.maintainability_score < 0.7:
            return RewriteType.CODE_CLEANUP
        else:
            return RewriteType.LOGIC_IMPROVEMENT
    
    async def _generate_improved_code(self, current_logic: str, rewrite_type: RewriteType, assessment: CodeAssessment) -> str:
        """Í∞úÏÑ†Îêú ÏΩîÎìú ÏÉùÏÑ±"""
        try:
            # Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÌòÑÏû¨ ÏΩîÎìúÎ•º Î∞òÌôò (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî AI Í∏∞Î∞ò ÏΩîÎìú ÏÉùÏÑ±)
            improved_code = current_logic
            
            # Ïû¨ÏûëÏÑ± Ïú†ÌòïÏóê Îî∞Î•∏ Í∞úÏÑ† Ï†ÅÏö©
            if rewrite_type == RewriteType.PERFORMANCE_OPTIMIZATION:
                improved_code = await self._optimize_performance(improved_code)
            elif rewrite_type == RewriteType.CODE_CLEANUP:
                improved_code = await self._cleanup_code(improved_code)
            elif rewrite_type == RewriteType.STRUCTURE_REORGANIZATION:
                improved_code = await self._reorganize_structure(improved_code)
            
            return improved_code
            
        except Exception as e:
            logger.error(f"Í∞úÏÑ†Îêú ÏΩîÎìú ÏÉùÏÑ± Ïã§Ìå®: {e}")
            return current_logic
    
    async def _optimize_performance(self, code: str) -> str:
        """ÏÑ±Îä• ÏµúÏ†ÅÌôî"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏÑ±Îä• ÏµúÏ†ÅÌôî Î°úÏßÅ Ï†ÅÏö©
        return code
    
    async def _cleanup_code(self, code: str) -> str:
        """ÏΩîÎìú Ï†ïÎ¶¨"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏΩîÎìú Ï†ïÎ¶¨ Î°úÏßÅ Ï†ÅÏö©
        return code
    
    async def _reorganize_structure(self, code: str) -> str:
        """Íµ¨Ï°∞ Ïû¨Íµ¨ÏÑ±"""
        # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Íµ¨Ï°∞ Ïû¨Íµ¨ÏÑ± Î°úÏßÅ Ï†ÅÏö©
        return code
    
    async def _generate_improvement_description(self, rewrite_type: RewriteType, assessment: CodeAssessment) -> str:
        """Í∞úÏÑ† ÏÑ§Î™Ö ÏÉùÏÑ±"""
        descriptions = {
            RewriteType.LOGIC_IMPROVEMENT: "Î°úÏßÅ Í∞úÏÑ†ÏùÑ ÌÜµÌïú ÏΩîÎìú ÌíàÏßà Ìñ•ÏÉÅ",
            RewriteType.PERFORMANCE_OPTIMIZATION: "ÏÑ±Îä• ÏµúÏ†ÅÌôîÎ•º ÌÜµÌïú Ïã§Ìñâ ÏÜçÎèÑ Ìñ•ÏÉÅ",
            RewriteType.CODE_CLEANUP: "ÏΩîÎìú Ï†ïÎ¶¨Î•º ÌÜµÌïú Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ",
            RewriteType.BUG_FIX: "Î≤ÑÍ∑∏ ÏàòÏ†ïÏùÑ ÌÜµÌïú ÏïàÏ†ïÏÑ± Ìñ•ÏÉÅ",
            RewriteType.STRUCTURE_REORGANIZATION: "Íµ¨Ï°∞ Ïû¨Íµ¨ÏÑ±ÏùÑ ÌÜµÌïú Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ìñ•ÏÉÅ"
        }
        
        return descriptions.get(rewrite_type, "ÏùºÎ∞òÏ†ÅÏù∏ ÏΩîÎìú Í∞úÏÑ†")
    
    async def _calculate_expected_impact(self, rewrite_type: RewriteType, assessment: CodeAssessment) -> float:
        """ÏòàÏÉÅ ÏòÅÌñ•ÎèÑ Í≥ÑÏÇ∞"""
        base_impact = 0.5
        
        if rewrite_type == RewriteType.PERFORMANCE_OPTIMIZATION:
            base_impact = 1.0 - assessment.performance_score
        elif rewrite_type == RewriteType.STRUCTURE_REORGANIZATION:
            base_impact = 1.0 - assessment.maintainability_score
        
        return min(1.0, max(0.0, base_impact))
    
    async def _calculate_risk_level(self, rewrite_type: RewriteType, proposed_code: str) -> float:
        """ÏúÑÌóò ÏàòÏ§Ä Í≥ÑÏÇ∞"""
        base_risk = 0.3
        
        if rewrite_type == RewriteType.STRUCTURE_REORGANIZATION:
            base_risk = 0.7
        elif rewrite_type == RewriteType.BUG_FIX:
            base_risk = 0.5
        
        return min(1.0, max(0.0, base_risk))
    
    async def _create_backup(self, target_file: str) -> str:
        """Î∞±ÏóÖ ÏÉùÏÑ±"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"{os.path.basename(target_file)}.backup_{timestamp}"
        backup_path = os.path.join(self.backup_directory, backup_filename)
        
        shutil.copy2(target_file, backup_path)
        logger.info(f"Î∞±ÏóÖ ÏÉùÏÑ±: {backup_path}")
        
        return backup_path
    
    async def _create_temp_file(self, new_logic: str) -> str:
        """ÏûÑÏãú ÌååÏùº ÏÉùÏÑ±"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(new_logic)
            temp_path = f.name
        
        return temp_path
    
    async def _run_tests(self, temp_file: str) -> Dict[str, Any]:
        """ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
        try:
            # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÌÖåÏä§Ìä∏ Ïä§ÏúÑÌä∏ Ïã§Ìñâ
            # Ïó¨Í∏∞ÏÑúÎäî ÏãúÎÆ¨Î†àÏù¥ÏÖò
            test_results = {
                'success': True,
                'tests_run': 5,
                'tests_passed': 5,
                'tests_failed': 0,
                'coverage': 0.85
            }
            
            return test_results
            
        except Exception as e:
            logger.error(f"ÌÖåÏä§Ìä∏ Ïã§Ìñâ Ïã§Ìå®: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _apply_changes(self, target_file: str, temp_file: str) -> None:
        """Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÅÏö©"""
        shutil.copy2(temp_file, target_file)
        os.unlink(temp_file)  # ÏûÑÏãú ÌååÏùº ÏÇ≠Ï†ú
        logger.info(f"Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÅÏö©: {target_file}")
    
    async def _record_changes(self, target_file: str, backup_file: str) -> List[str]:
        """Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù"""
        try:
            with open(target_file, 'r') as f1, open(backup_file, 'r') as f2:
                current_lines = f1.readlines()
                backup_lines = f2.readlines()
            
            diff = list(difflib.unified_diff(backup_lines, current_lines, 
                                           fromfile=backup_file, tofile=target_file))
            
            changes = []
            for line in diff:
                if line.startswith('+') and not line.startswith('+++'):
                    changes.append(f"Ï∂îÍ∞Ä: {line[1:].strip()}")
                elif line.startswith('-') and not line.startswith('---'):
                    changes.append(f"ÏÇ≠Ï†ú: {line[1:].strip()}")
            
            return changes
            
        except Exception as e:
            logger.error(f"Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù Ïã§Ìå®: {e}")
            return ["Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù Ïã§Ìå®"]
    
    async def _rollback_changes(self, target_file: str, backup_file: str) -> None:
        """Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î°§Î∞±"""
        shutil.copy2(backup_file, target_file)
        logger.info(f"Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î°§Î∞±: {target_file}")
    
    async def _create_default_assessment(self, module_path: str) -> CodeAssessment:
        """Í∏∞Î≥∏ ÌèâÍ∞Ä ÏÉùÏÑ±"""
        return CodeAssessment(
            module_path=module_path,
            complexity_score=0.5,
            performance_score=0.7,
            maintainability_score=0.8,
            bug_potential=0.3,
            improvement_opportunities=[]
        )
    
    async def _create_default_proposal(self, current_logic: str, assessment: CodeAssessment) -> RewriteProposal:
        """Í∏∞Î≥∏ Ï†úÏïà ÏÉùÏÑ±"""
        return RewriteProposal(
            proposal_id=f"default_proposal_{int(time.time() * 1000)}",
            rewrite_type=RewriteType.LOGIC_IMPROVEMENT,
            target_file=assessment.module_path,
            current_code=current_logic,
            proposed_code=current_logic,
            improvement_description="Í∏∞Î≥∏ Í∞úÏÑ† Ï†úÏïà",
            expected_impact=0.1,
            risk_level=0.1
        )
    
    async def _create_failed_result(self, target_file: str, error_message: str) -> RewriteResult:
        """Ïã§Ìå® Í≤∞Í≥º ÏÉùÏÑ±"""
        return RewriteResult(
            success=False,
            original_file=target_file,
            backup_file="",
            new_file=target_file,
            changes_made=[],
            test_results={},
            execution_time=0.0,
            status=RewriteStatus.FAILED,
            error_message=error_message
        )


async def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    # Self-Rewriting Module Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
    self_rewriter = SelfRewritingModule()
    
    # ÌÖåÏä§Ìä∏Ïö© Î™®Îìà Í≤ΩÎ°ú
    test_module = "DuRiCore/duri_thought_flow.py"
    
    # ÏΩîÎìú ÌèâÍ∞Ä
    assessment = await self_rewriter.assess_self_code(test_module)
    
    # ÌòÑÏû¨ ÏΩîÎìú ÏùΩÍ∏∞
    with open(test_module, 'r', encoding='utf-8') as f:
        current_code = f.read()
    
    # Í∞úÏÑ†Îêú Î°úÏßÅ Ï†úÏïà
    proposal = await self_rewriter.generate_alternative(current_code, assessment)
    
    # Í≤∞Í≥º Ï∂úÎ†•
    print("\n" + "="*80)
    print("üß† Self-Rewriting Module ÌÖåÏä§Ìä∏ Í≤∞Í≥º")
    print("="*80)
    
    print(f"\nüìä ÏΩîÎìú ÌèâÍ∞Ä:")
    print(f"  - Î≥µÏû°ÎèÑ Ï†êÏàò: {assessment.complexity_score:.2f}")
    print(f"  - ÏÑ±Îä• Ï†êÏàò: {assessment.performance_score:.2f}")
    print(f"  - Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ï†êÏàò: {assessment.maintainability_score:.2f}")
    print(f"  - Î≤ÑÍ∑∏ Ïû†Ïû¨ÏÑ±: {assessment.bug_potential:.2f}")
    
    print(f"\nüéØ Í∞úÏÑ† Ï†úÏïà:")
    print(f"  - Ïû¨ÏûëÏÑ± Ïú†Ìòï: {proposal.rewrite_type.value}")
    print(f"  - ÏòàÏÉÅ ÏòÅÌñ•ÎèÑ: {proposal.expected_impact:.2f}")
    print(f"  - ÏúÑÌóò ÏàòÏ§Ä: {proposal.risk_level:.2f}")
    print(f"  - Í∞úÏÑ† ÏÑ§Î™Ö: {proposal.improvement_description}")
    
    return assessment, proposal


if __name__ == "__main__":
    asyncio.run(main()) 