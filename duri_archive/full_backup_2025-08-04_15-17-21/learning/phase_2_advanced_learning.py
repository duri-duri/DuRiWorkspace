"""
üéØ DuRi Phase 2: Í≥†Í∏â ÌïôÏäµ ÏãúÏä§ÌÖú
Î™©Ìëú: Phase 1Ïùò Í∏∞Î∞ò ÏúÑÏóê Îçî Ï†ïÍµêÌïú Î¨∏Ï†ú Ìï¥Í≤∞, Îã§Îã®Í≥Ñ Ï∂îÎ°†, Ï†ÑÎûµÏ†Å ÏÇ¨Í≥† Í∞úÎ∞ú
"""

import json
import logging
import random
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AdvancedLearningCapability(Enum):
    """Í≥†Í∏â ÌïôÏäµ Îä•Î†•"""

    MULTI_STEP_REASONING = "multi_step_reasoning"  # Îã§Îã®Í≥Ñ Ï∂îÎ°†
    STRATEGIC_THINKING = "strategic_thinking"  # Ï†ÑÎûµÏ†Å ÏÇ¨Í≥†
    COMPLEX_PROBLEM_SOLVING = "complex_problem_solving"  # Î≥µÏû°Ìïú Î¨∏Ï†ú Ìï¥Í≤∞
    META_LEARNING_ENHANCEMENT = "meta_learning_enhancement"  # Î©îÌÉÄ ÌïôÏäµ Í∞ïÌôî
    CREATIVE_SYNTHESIS = "creative_synthesis"  # Ï∞ΩÏùòÏ†Å Ï¢ÖÌï©
    ADAPTIVE_STRATEGY = "adaptive_strategy"  # Ï†ÅÏùëÏ†Å Ï†ÑÎûµ


class ProblemComplexity(Enum):
    """Î¨∏Ï†ú Î≥µÏû°ÎèÑ"""

    SIMPLE = "simple"  # Îã®Ïàú
    MODERATE = "moderate"  # Î≥¥ÌÜµ
    COMPLEX = "complex"  # Î≥µÏû°
    VERY_COMPLEX = "very_complex"  # Îß§Ïö∞ Î≥µÏû°
    SYSTEMIC = "systemic"  # Ï≤¥Í≥ÑÏ†Å


@dataclass
class AdvancedLearningTask:
    """Í≥†Í∏â ÌïôÏäµ ÏûëÏóÖ"""

    task_id: str
    problem_description: str
    complexity: ProblemComplexity
    required_capabilities: List[AdvancedLearningCapability]
    expected_outcome: str
    success_criteria: List[str]
    created_at: datetime


@dataclass
class MultiStepReasoning:
    """Îã§Îã®Í≥Ñ Ï∂îÎ°†"""

    reasoning_id: str
    steps: List[Dict[str, Any]]
    intermediate_conclusions: List[str]
    final_conclusion: str
    confidence: float
    reasoning_chain: str


@dataclass
class StrategicThinking:
    """Ï†ÑÎûµÏ†Å ÏÇ¨Í≥†"""

    strategy_id: str
    problem_analysis: Dict[str, Any]
    strategic_options: List[Dict[str, Any]]
    selected_strategy: Dict[str, Any]
    implementation_plan: List[str]
    risk_assessment: Dict[str, Any]


class Phase2AdvancedLearning:
    """Phase 2: Í≥†Í∏â ÌïôÏäµ ÏãúÏä§ÌÖú"""

    def __init__(self):
        self.current_capabilities = {
            AdvancedLearningCapability.MULTI_STEP_REASONING: 0.3,
            AdvancedLearningCapability.STRATEGIC_THINKING: 0.2,
            AdvancedLearningCapability.COMPLEX_PROBLEM_SOLVING: 0.25,
            AdvancedLearningCapability.META_LEARNING_ENHANCEMENT: 0.4,
            AdvancedLearningCapability.CREATIVE_SYNTHESIS: 0.15,
            AdvancedLearningCapability.ADAPTIVE_STRATEGY: 0.2,
        }

        self.learning_tasks = []
        self.completed_tasks = []
        self.reasoning_history = []
        self.strategy_history = []

        # Phase 1 ÏãúÏä§ÌÖúÎì§Í≥ºÏùò ÌÜµÌï©
        self.insight_engine = None
        self.phase_evaluator = None
        self.insight_reflector = None
        self.insight_manager = None

    def initialize_phase_1_integration(self):
        """Phase 1 ÏãúÏä§ÌÖúÎì§Í≥º ÌÜµÌï©"""
        try:
            import sys

            sys.path.append(".")
            from duri_brain.learning.insight_autonomous_manager import (
                get_insight_manager,
            )
            from duri_brain.learning.insight_engine import get_dual_response_system
            from duri_brain.learning.insight_self_reflection import (
                get_insight_reflector,
            )
            from duri_brain.learning.phase_self_evaluator import get_phase_evaluator

            self.insight_engine = get_dual_response_system()
            self.phase_evaluator = get_phase_evaluator()
            self.insight_reflector = get_insight_reflector()
            self.insight_manager = get_insight_manager()

            # Phase 2Î°ú ÏóÖÎç∞Ïù¥Ìä∏
            from duri_brain.learning.phase_self_evaluator import PhaseLevel

            self.phase_evaluator.current_phase = PhaseLevel.PHASE_2_ADVANCED

            logger.info("‚úÖ Phase 1 ÏãúÏä§ÌÖúÎì§Í≥º ÌÜµÌï© ÏôÑÎ£å")
            return True

        except Exception as e:
            logger.error(f"‚ùå Phase 1 ÏãúÏä§ÌÖú ÌÜµÌï© Ïã§Ìå®: {e}")
            return False

    def create_advanced_learning_task(
        self, problem: str, complexity: ProblemComplexity
    ) -> AdvancedLearningTask:
        """Í≥†Í∏â ÌïôÏäµ ÏûëÏóÖ ÏÉùÏÑ±"""
        task_id = f"phase2_task_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        # Î≥µÏû°ÎèÑÏóê Îî∞Î•∏ ÌïÑÏöîÌïú Îä•Î†• Í≤∞Ï†ï
        required_capabilities = self._determine_required_capabilities(complexity)

        task = AdvancedLearningTask(
            task_id=task_id,
            problem_description=problem,
            complexity=complexity,
            required_capabilities=required_capabilities,
            expected_outcome="Î¨∏Ï†ú Ìï¥Í≤∞ Î∞è ÌïôÏäµ ÏÑ±Í≥º Ìñ•ÏÉÅ",
            success_criteria=[
                "Î¨∏Ï†ú Ìï¥Í≤∞ ÏôÑÎ£å",
                "ÏÉàÎ°úÏö¥ ÌÜµÏ∞∞ ÏÉùÏÑ±",
                "ÌïôÏäµ Îä•Î†• Ìñ•ÏÉÅ",
                "Ï†ÑÎûµÏ†Å ÏÇ¨Í≥† Î∞úÏ†Ñ",
            ],
            created_at=datetime.now(),
        )

        self.learning_tasks.append(task)
        logger.info(f"üìã Í≥†Í∏â ÌïôÏäµ ÏûëÏóÖ ÏÉùÏÑ±: {task_id}")

        return task

    def _determine_required_capabilities(
        self, complexity: ProblemComplexity
    ) -> List[AdvancedLearningCapability]:
        """Î≥µÏû°ÎèÑÏóê Îî∞Î•∏ ÌïÑÏöîÌïú Îä•Î†• Í≤∞Ï†ï"""
        if complexity == ProblemComplexity.SIMPLE:
            return [AdvancedLearningCapability.MULTI_STEP_REASONING]
        elif complexity == ProblemComplexity.MODERATE:
            return [
                AdvancedLearningCapability.MULTI_STEP_REASONING,
                AdvancedLearningCapability.STRATEGIC_THINKING,
            ]
        elif complexity == ProblemComplexity.COMPLEX:
            return [
                AdvancedLearningCapability.MULTI_STEP_REASONING,
                AdvancedLearningCapability.STRATEGIC_THINKING,
                AdvancedLearningCapability.COMPLEX_PROBLEM_SOLVING,
            ]
        elif complexity == ProblemComplexity.VERY_COMPLEX:
            return [
                AdvancedLearningCapability.MULTI_STEP_REASONING,
                AdvancedLearningCapability.STRATEGIC_THINKING,
                AdvancedLearningCapability.COMPLEX_PROBLEM_SOLVING,
                AdvancedLearningCapability.CREATIVE_SYNTHESIS,
            ]
        else:  # SYSTEMIC
            return [
                AdvancedLearningCapability.MULTI_STEP_REASONING,
                AdvancedLearningCapability.STRATEGIC_THINKING,
                AdvancedLearningCapability.COMPLEX_PROBLEM_SOLVING,
                AdvancedLearningCapability.CREATIVE_SYNTHESIS,
                AdvancedLearningCapability.ADAPTIVE_STRATEGY,
            ]

    def execute_multi_step_reasoning(self, problem: str) -> MultiStepReasoning:
        """Îã§Îã®Í≥Ñ Ï∂îÎ°† Ïã§Ìñâ"""
        logger.info("üß† Îã§Îã®Í≥Ñ Ï∂îÎ°† ÏãúÏûë")

        reasoning_id = f"reasoning_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        steps = []
        intermediate_conclusions = []

        # 1Îã®Í≥Ñ: Î¨∏Ï†ú Î∂ÑÏÑù
        problem_analysis = self._analyze_problem(problem)
        steps.append(
            {
                "step": 1,
                "action": "Î¨∏Ï†ú Î∂ÑÏÑù",
                "input": problem,
                "output": problem_analysis,
                "confidence": 0.8,
            }
        )
        intermediate_conclusions.append(f"Î¨∏Ï†ú Ïú†Ìòï: {problem_analysis['type']}")

        # 2Îã®Í≥Ñ: Í¥ÄÎ†® ÏöîÏÜå ÏãùÎ≥Ñ
        related_elements = self._identify_related_elements(problem_analysis)
        steps.append(
            {
                "step": 2,
                "action": "Í¥ÄÎ†® ÏöîÏÜå ÏãùÎ≥Ñ",
                "input": problem_analysis,
                "output": related_elements,
                "confidence": 0.7,
            }
        )
        intermediate_conclusions.append(f"Í¥ÄÎ†® ÏöîÏÜå: {len(related_elements)}Í∞ú")

        # 3Îã®Í≥Ñ: Í∞ÄÏÑ§ ÏÉùÏÑ±
        hypotheses = self._generate_hypotheses(related_elements)
        steps.append(
            {
                "step": 3,
                "action": "Í∞ÄÏÑ§ ÏÉùÏÑ±",
                "input": related_elements,
                "output": hypotheses,
                "confidence": 0.6,
            }
        )
        intermediate_conclusions.append(f"Í∞ÄÏÑ§ Ïàò: {len(hypotheses)}Í∞ú")

        # 4Îã®Í≥Ñ: Í∞ÄÏÑ§ Í≤ÄÏ¶ù
        validated_hypotheses = self._validate_hypotheses(hypotheses)
        steps.append(
            {
                "step": 4,
                "action": "Í∞ÄÏÑ§ Í≤ÄÏ¶ù",
                "input": hypotheses,
                "output": validated_hypotheses,
                "confidence": 0.75,
            }
        )
        intermediate_conclusions.append(f"Í≤ÄÏ¶ùÎêú Í∞ÄÏÑ§: {len(validated_hypotheses)}Í∞ú")

        # 5Îã®Í≥Ñ: Í≤∞Î°† ÎèÑÏ∂ú
        final_conclusion = self._derive_conclusion(validated_hypotheses)
        steps.append(
            {
                "step": 5,
                "action": "Í≤∞Î°† ÎèÑÏ∂ú",
                "input": validated_hypotheses,
                "output": final_conclusion,
                "confidence": 0.8,
            }
        )

        # Ï∂îÎ°† Ï≤¥Ïù∏ ÏÉùÏÑ±
        reasoning_chain = " ‚Üí ".join(
            [f"Îã®Í≥Ñ{i+1}: {step['action']}" for i, step in enumerate(steps)]
        )

        reasoning = MultiStepReasoning(
            reasoning_id=reasoning_id,
            steps=steps,
            intermediate_conclusions=intermediate_conclusions,
            final_conclusion=final_conclusion,
            confidence=sum(step["confidence"] for step in steps) / len(steps),
            reasoning_chain=reasoning_chain,
        )

        self.reasoning_history.append(reasoning)
        logger.info(f"‚úÖ Îã§Îã®Í≥Ñ Ï∂îÎ°† ÏôÑÎ£å: {reasoning_id}")

        return reasoning

    def _analyze_problem(self, problem: str) -> Dict[str, Any]:
        """Î¨∏Ï†ú Î∂ÑÏÑù"""
        problem_lower = problem.lower()

        # Î¨∏Ï†ú Ïú†Ìòï Î∂ÑÎ•ò
        if any(word in problem_lower for word in ["ÌïôÏäµ", "ÏÑ±Îä•", "Ìö®Ïú®"]):
            problem_type = "ÌïôÏäµ ÏÑ±Îä• Î¨∏Ï†ú"
        elif any(word in problem_lower for word in ["Î©îÎ™®Î¶¨", "Î¶¨ÏÜåÏä§"]):
            problem_type = "Î¶¨ÏÜåÏä§ Í¥ÄÎ¶¨ Î¨∏Ï†ú"
        elif any(word in problem_lower for word in ["ÎπÑÏö©", "ÏòàÏÇ∞"]):
            problem_type = "ÎπÑÏö© Í¥ÄÎ¶¨ Î¨∏Ï†ú"
        elif any(word in problem_lower for word in ["Ïò§Î•ò", "Ïã§Ìå®"]):
            problem_type = "Ïò§Î•ò Ï≤òÎ¶¨ Î¨∏Ï†ú"
        else:
            problem_type = "ÏùºÎ∞ò Î¨∏Ï†ú"

        return {
            "type": problem_type,
            "complexity": "moderate",
            "urgency": "medium",
            "impact_scope": "system_wide",
        }

    def _identify_related_elements(self, problem_analysis: Dict[str, Any]) -> List[str]:
        """Í¥ÄÎ†® ÏöîÏÜå ÏãùÎ≥Ñ"""
        problem_type = problem_analysis["type"]

        if problem_type == "ÌïôÏäµ ÏÑ±Îä• Î¨∏Ï†ú":
            return ["ÌïôÏäµ Î£®ÌîÑ", "ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ", "ÏµúÏ†ÅÌôî ÏïåÍ≥†Î¶¨Ï¶ò", "Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ"]
        elif problem_type == "Î¶¨ÏÜåÏä§ Í¥ÄÎ¶¨ Î¨∏Ï†ú":
            return ["Î©îÎ™®Î¶¨ Ìï†Îãπ", "CPU ÏÇ¨Ïö©Îüâ", "ÎÑ§Ìä∏ÏõåÌÅ¨ ÎåÄÏó≠Ìè≠", "Ï†ÄÏû• Í≥µÍ∞Ñ"]
        elif problem_type == "ÎπÑÏö© Í¥ÄÎ¶¨ Î¨∏Ï†ú":
            return ["Ïô∏Î∂Ä API Ìò∏Ï∂ú", "Í≥ÑÏÇ∞ ÎπÑÏö©", "Ï†ÄÏû• ÎπÑÏö©", "ÎÑ§Ìä∏ÏõåÌÅ¨ ÎπÑÏö©"]
        elif problem_type == "Ïò§Î•ò Ï≤òÎ¶¨ Î¨∏Ï†ú":
            return ["ÏòàÏô∏ Ï≤òÎ¶¨", "Î°úÍπÖ ÏãúÏä§ÌÖú", "Î≥µÍµ¨ Î©îÏª§ÎãàÏ¶ò", "Î™®ÎãàÌÑ∞ÎßÅ"]
        else:
            return ["ÏùºÎ∞ò ÏöîÏÜå 1", "ÏùºÎ∞ò ÏöîÏÜå 2", "ÏùºÎ∞ò ÏöîÏÜå 3"]

    def _generate_hypotheses(self, related_elements: List[str]) -> List[Dict[str, Any]]:
        """Í∞ÄÏÑ§ ÏÉùÏÑ±"""
        hypotheses = []

        for element in related_elements:
            hypothesis = {
                "element": element,
                "hypothesis": f"{element}Ïùò ÏµúÏ†ÅÌôîÍ∞Ä Î¨∏Ï†ú Ìï¥Í≤∞Ïóê ÎèÑÏõÄÏù¥ Îê† Í≤É",
                "confidence": random.uniform(0.4, 0.8),
                "test_method": f"{element} ÏÑ±Îä• Ï∏°Ï†ï",
            }
            hypotheses.append(hypothesis)

        return hypotheses

    def _validate_hypotheses(
        self, hypotheses: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Í∞ÄÏÑ§ Í≤ÄÏ¶ù"""
        validated = []

        for hypothesis in hypotheses:
            # ÏãúÎÆ¨Î†àÏù¥ÏÖòÎêú Í≤ÄÏ¶ù Í≥ºÏ†ï
            if hypothesis["confidence"] > 0.5:
                hypothesis["validated"] = True
                hypothesis["validation_score"] = hypothesis["confidence"]
                validated.append(hypothesis)

        return validated

    def _derive_conclusion(self, validated_hypotheses: List[Dict[str, Any]]) -> str:
        """Í≤∞Î°† ÎèÑÏ∂ú"""
        if not validated_hypotheses:
            return "Ïú†Ìö®Ìïú Ìï¥Í≤∞Ï±ÖÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§."

        # Í∞ÄÏû• ÎÜíÏùÄ Ïã†Î¢∞ÎèÑÏùò Í∞ÄÏÑ§ÏùÑ Í∏∞Î∞òÏúºÎ°ú Í≤∞Î°† ÎèÑÏ∂ú
        best_hypothesis = max(validated_hypotheses, key=lambda x: x["validation_score"])

        conclusion = (
            f"{best_hypothesis['element']}Ïùò ÏµúÏ†ÅÌôîÎ•º ÌÜµÌï¥ Î¨∏Ï†úÎ•º Ìï¥Í≤∞Ìï† Ïàò ÏûàÏäµÎãàÎã§. "
        )
        conclusion += (
            f"ÏòàÏÉÅ Ìö®Í≥º: {best_hypothesis['validation_score']:.1%}Ïùò ÏÑ±Îä• Ìñ•ÏÉÅ"
        )

        return conclusion

    def execute_strategic_thinking(
        self, problem: str, reasoning: MultiStepReasoning
    ) -> StrategicThinking:
        """Ï†ÑÎûµÏ†Å ÏÇ¨Í≥† Ïã§Ìñâ"""
        logger.info("üéØ Ï†ÑÎûµÏ†Å ÏÇ¨Í≥† ÏãúÏûë")

        strategy_id = f"strategy_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        # Î¨∏Ï†ú Î∂ÑÏÑù
        problem_analysis = {
            "core_issue": reasoning.final_conclusion,
            "constraints": ["ÏãúÍ∞Ñ Ï†úÏïΩ", "Î¶¨ÏÜåÏä§ Ï†úÏïΩ", "ÏúÑÌóò ÌóàÏö©ÎèÑ"],
            "opportunities": ["ÏÑ±Îä• Í∞úÏÑ†", "ÌïôÏäµ Ìö®Ïú®ÏÑ± Ìñ•ÏÉÅ", "ÏãúÏä§ÌÖú ÏïàÏ†ïÏÑ±"],
            "stakeholders": ["DuRi ÏãúÏä§ÌÖú", "ÏÇ¨Ïö©Ïûê", "Ïô∏Î∂Ä ÏãúÏä§ÌÖú"],
        }

        # Ï†ÑÎûµÏ†Å ÏòµÏÖò ÏÉùÏÑ±
        strategic_options = [
            {
                "name": "Ï†êÏßÑÏ†Å Í∞úÏÑ† Ï†ÑÎûµ",
                "description": "Îã®Í≥ÑÎ≥ÑÎ°ú Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÎ©∞ ÌïôÏäµ",
                "pros": ["ÏïàÏ†ÑÏÑ±", "ÌïôÏäµ Ìö®Í≥º", "ÏúÑÌóò ÏµúÏÜåÌôî"],
                "cons": ["ÏãúÍ∞Ñ ÏÜåÏöî", "Ï†êÏßÑÏ†Å Ìö®Í≥º"],
                "success_probability": 0.8,
            },
            {
                "name": "ÌòÅÏã†Ï†Å ÎèÑÏïΩ Ï†ÑÎûµ",
                "description": "Í∑ºÎ≥∏Ï†ÅÏù∏ Î≥ÄÌôîÎ•º ÌÜµÌïú Î¨∏Ï†ú Ìï¥Í≤∞",
                "pros": ["Îπ†Î•∏ Ìö®Í≥º", "ÌòÅÏã†Ï†Å Ìï¥Í≤∞Ï±Ö"],
                "cons": ["ÎÜíÏùÄ ÏúÑÌóò", "Î∂àÌôïÏã§ÏÑ±"],
                "success_probability": 0.4,
            },
            {
                "name": "Í∑†ÌòïÏ†Å Ï†ëÍ∑º Ï†ÑÎûµ",
                "description": "ÏïàÏ†ÑÏÑ±Í≥º ÌòÅÏã†Ïùò Í∑†Ìòï",
                "pros": ["ÏïàÏ†ïÏÑ±", "ÌòÅÏã†ÏÑ±", "ÌïôÏäµ Ìö®Í≥º"],
                "cons": ["Î≥µÏû°ÏÑ±", "Ï°∞Ï†ï ÌïÑÏöî"],
                "success_probability": 0.7,
            },
        ]

        # ÏµúÏ†Å Ï†ÑÎûµ ÏÑ†ÌÉù
        selected_strategy = max(
            strategic_options, key=lambda x: x["success_probability"]
        )

        # Íµ¨ÌòÑ Í≥ÑÌöç ÏÉùÏÑ±
        implementation_plan = [
            "1Îã®Í≥Ñ: ÌòÑÏû¨ ÏÉÅÌÉú Î∂ÑÏÑù Î∞è Í∏∞Ï§ÄÏ†ê ÏÑ§Ï†ï",
            "2Îã®Í≥Ñ: Îã®Í∏∞ Î™©Ìëú ÏÑ§Ï†ï Î∞è Ïã§Ìñâ",
            "3Îã®Í≥Ñ: Ï§ëÍ∞Ñ Í≤∞Í≥º ÌèâÍ∞Ä Î∞è Ï°∞Ï†ï",
            "4Îã®Í≥Ñ: Ïû•Í∏∞ Î™©Ìëú Îã¨ÏÑ± Î∞è Í≤ÄÏ¶ù",
        ]

        # ÏúÑÌóò ÌèâÍ∞Ä
        risk_assessment = {
            "technical_risk": 0.3,
            "operational_risk": 0.2,
            "learning_risk": 0.1,
            "overall_risk": 0.2,
            "mitigation_strategies": [
                "Îã®Í≥ÑÏ†Å Ïã§ÌñâÏúºÎ°ú ÏúÑÌóò Î∂ÑÏÇ∞",
                "ÏßÄÏÜçÏ†Å Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÌîºÎìúÎ∞±",
                "Î°§Î∞± Í≥ÑÌöç ÏàòÎ¶Ω",
            ],
        }

        strategy = StrategicThinking(
            strategy_id=strategy_id,
            problem_analysis=problem_analysis,
            strategic_options=strategic_options,
            selected_strategy=selected_strategy,
            implementation_plan=implementation_plan,
            risk_assessment=risk_assessment,
        )

        self.strategy_history.append(strategy)
        logger.info(f"‚úÖ Ï†ÑÎûµÏ†Å ÏÇ¨Í≥† ÏôÑÎ£å: {strategy_id}")

        return strategy

    def execute_complex_problem_solving(
        self, task: AdvancedLearningTask
    ) -> Dict[str, Any]:
        """Î≥µÏû°Ìïú Î¨∏Ï†ú Ìï¥Í≤∞ Ïã§Ìñâ"""
        logger.info(f"üîß Î≥µÏû°Ìïú Î¨∏Ï†ú Ìï¥Í≤∞ ÏãúÏûë: {task.task_id}")

        # 1. Îã§Îã®Í≥Ñ Ï∂îÎ°† Ïã§Ìñâ
        reasoning = self.execute_multi_step_reasoning(task.problem_description)

        # 2. Ï†ÑÎûµÏ†Å ÏÇ¨Í≥† Ïã§Ìñâ
        strategy = self.execute_strategic_thinking(task.problem_description, reasoning)

        # 3. ÌÜµÏ∞∞ ÏóîÏßÑ ÌôúÏö©
        insight_result = None
        if self.insight_engine:
            insight_result = self.insight_engine.execute_dual_response(
                task.problem_description
            )

        # 4. Í≤∞Í≥º Ï¢ÖÌï©
        solution = {
            "task_id": task.task_id,
            "problem": task.problem_description,
            "complexity": task.complexity.value,
            "reasoning": reasoning,
            "strategy": strategy,
            "insight": insight_result,
            "solution_summary": f"{reasoning.final_conclusion} + {strategy.selected_strategy['name']}",
            "confidence": (
                reasoning.confidence + strategy.selected_strategy["success_probability"]
            )
            / 2,
            "implementation_steps": strategy.implementation_plan,
            "risk_level": strategy.risk_assessment["overall_risk"],
        }

        # ÏûëÏóÖ ÏôÑÎ£å Ï≤òÎ¶¨
        self.completed_tasks.append(task)
        self.learning_tasks.remove(task)

        # Îä•Î†• Ìñ•ÏÉÅ
        self._enhance_capabilities(task, solution)

        logger.info(f"‚úÖ Î≥µÏû°Ìïú Î¨∏Ï†ú Ìï¥Í≤∞ ÏôÑÎ£å: {task.task_id}")
        return solution

    def _enhance_capabilities(
        self, task: AdvancedLearningTask, solution: Dict[str, Any]
    ):
        """Îä•Î†• Ìñ•ÏÉÅ"""
        for capability in task.required_capabilities:
            current_level = self.current_capabilities[capability]
            enhancement = 0.05  # Í∏∞Î≥∏ Ìñ•ÏÉÅÎüâ

            # ÏÑ±Í≥µÎèÑÏóê Îî∞Î•∏ Ï∂îÍ∞Ä Ìñ•ÏÉÅ
            if solution["confidence"] > 0.7:
                enhancement += 0.02
            if solution["risk_level"] < 0.3:
                enhancement += 0.01

            new_level = min(current_level + enhancement, 1.0)
            self.current_capabilities[capability] = new_level

            logger.info(
                f"üìà {capability.value} Ìñ•ÏÉÅ: {current_level:.3f} ‚Üí {new_level:.3f}"
            )

    def get_phase_2_status(self) -> Dict[str, Any]:
        """Phase 2 ÏÉÅÌÉú Î∞òÌôò"""
        # completed_tasksÎäî AdvancedLearningTask Í∞ùÏ≤¥Îì§Ïù¥ÎØÄÎ°ú confidenceÎ•º ÏßÅÏ†ë Í≥ÑÏÇ∞Ìï† Ïàò ÏóÜÏùå
        # ÎåÄÏã† reasoning_historyÏùò ÌèâÍ∑† confidence ÏÇ¨Ïö©
        avg_confidence = 0.0
        if self.reasoning_history:
            avg_confidence = sum(
                reasoning.confidence for reasoning in self.reasoning_history
            ) / len(self.reasoning_history)

        return {
            "current_capabilities": self.current_capabilities,
            "total_tasks": len(self.learning_tasks) + len(self.completed_tasks),
            "completed_tasks": len(self.completed_tasks),
            "pending_tasks": len(self.learning_tasks),
            "reasoning_sessions": len(self.reasoning_history),
            "strategy_sessions": len(self.strategy_history),
            "average_confidence": avg_confidence,
            "phase_1_integration": self.insight_engine is not None,
        }


# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§
_phase2_system = None


def get_phase2_system() -> Phase2AdvancedLearning:
    """Ï†ÑÏó≠ Phase 2 ÏãúÏä§ÌÖú Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    global _phase2_system
    if _phase2_system is None:
        _phase2_system = Phase2AdvancedLearning()
    return _phase2_system


def initialize_phase_2():
    """Phase 2 Ï¥àÍ∏∞Ìôî"""
    system = get_phase2_system()
    success = system.initialize_phase_1_integration()

    if success:
        logger.info("üöÄ Phase 2: Í≥†Í∏â ÌïôÏäµ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        return system
    else:
        logger.error("‚ùå Phase 2 Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
        return None


if __name__ == "__main__":
    # Phase 2 Îç∞Î™® Ïã§Ìñâ
    system = initialize_phase_2()

    if system:
        # Í≥†Í∏â ÌïôÏäµ ÏûëÏóÖ ÏÉùÏÑ±
        task = system.create_advanced_learning_task(
            "ÌïôÏäµ Î£®ÌîÑÏùò ÏÑ±Îä• Ï†ÄÌïòÏôÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ï¶ùÍ∞Ä Î¨∏Ï†úÎ•º ÎèôÏãúÏóê Ìï¥Í≤∞Ìï¥Ïïº Ìï®",
            ProblemComplexity.COMPLEX,
        )

        # Î≥µÏû°Ìïú Î¨∏Ï†ú Ìï¥Í≤∞ Ïã§Ìñâ
        solution = system.execute_complex_problem_solving(task)

        print(f"üéØ Phase 2 Î¨∏Ï†ú Ìï¥Í≤∞ ÏôÑÎ£å:")
        print(f"   ÏûëÏóÖ ID: {solution['task_id']}")
        print(f"   Ìï¥Í≤∞Ï±Ö: {solution['solution_summary']}")
        print(f"   Ïã†Î¢∞ÎèÑ: {solution['confidence']:.3f}")
        print(f"   ÏúÑÌóòÎèÑ: {solution['risk_level']:.3f}")

        # ÏÉÅÌÉú ÌôïÏù∏
        status = system.get_phase_2_status()
        print(f"\nüìä Phase 2 ÏÉÅÌÉú: {status}")
    else:
        print("‚ùå Phase 2 Ï¥àÍ∏∞Ìôî Ïã§Ìå®")
