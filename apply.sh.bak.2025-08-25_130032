#!/usr/bin/env bash
set -Eeuo pipefail

# ---- SELF-TEST (runs before any normal flow) ----
if [[ "${1:-}" == "--self-test" ]]; then
  set -euo pipefail
  USB=${USB:-/mnt/usb}; HDD=${HDD:-/mnt/hdd}; PLAN=${PLAN:?need PLAN.jsonl}

  echo "[SELF-TEST] 1/3 ALL GREEN 기대"
  ./apply.sh --verify-only --quiet

  echo "[SELF-TEST] 2/3 한 바이트 손상 → 실패 기대"
  PB="$(jq -r 'if type=="array" then .[] else . end
    | select(.src|test("/FULL__"))
    | (.src|capture("(?<base>FULL__.*)").base)' "$PLAN")"
  T="$(mktemp)"
  cp -- "$HDD/ARCHIVE/FULL/$PB" "$T"
  dd if=/dev/zero of="$T" bs=1 count=1 seek=0 conv=notrunc status=none
  sudo mv -- "$T" "$HDD/ARCHIVE/FULL/$PB"

  set +e
  ./apply.sh --verify-only --quiet
  rc=$?
  set -e
  echo "[RESULT] exit=$rc (expect 1)"

  echo "[SELF-TEST] 3/3 원복"
  sudo cp -- "$USB/CORE_PROTECTED/$PB" "$HDD/ARCHIVE/FULL/$PB"
  exit "$rc"
fi
# ---- END SELF-TEST ----

# =========================
# 옵션 파싱
# =========================
VERIFY_ONLY=0
KEEP_TMP=0
FULL_MANIFEST=0
QUIET=0
for arg in "$@"; do
  case "$arg" in
    --verify-only) VERIFY_ONLY=1 ;;
    --keep-tmp) KEEP_TMP=1 ;;
    --full-manifest) FULL_MANIFEST=1 ;;
    --quiet) QUIET=1 ;;
  esac
done

# =========================
# 환경변수
# =========================
APPLY="${APPLY:-0}"                 # 0=DRY, 1=실행
USB="${USB:-/mnt/usb}"
HDD="${HDD:-/mnt/hdd}"
PLAN="${PLAN:?need PLAN.jsonl}"

CORE_OUT="$USB/CORE_PROTECTED"
FINAL_OUT="$USB/FINAL"
HDD_AR="$HDD/ARCHIVE"
META_DIR="${META_DIR:-$CORE_OUT/META}"

# =========================
# PLAN 사전 가드레일
# =========================
if jq -r 'if type=="array" then .[] else . end | .dst // empty' "$PLAN" \
   | grep -E -v '^/mnt/hdd/ARCHIVE/(FULL|INCR)/' | grep . >/dev/null 2>&1; then
  echo "[ERR] invalid dst in plan (must start with /mnt/hdd/ARCHIVE/(FULL|INCR)/)"
  exit 2
fi

# =========================
# 정확 매칭 해시 검증 함수
# =========================
check_one_exact() {
  local f="$1" base stem meta line hfile hmeta
  base="$(basename "$f")"
  stem="${base%.tar.zst}"
  meta="$META_DIR/SHA256SUMS.${stem}.txt"

  if [[ -f "$meta" ]]; then
    line="$(grep -F -- "  $base" "$meta" | head -1)"
    [[ -z "$line" ]] && { [[ $QUIET -eq 0 ]] && echo "[META-NOLINE] $base in $(basename "$meta")"; return 2; }
    hmeta="$(printf '%s\n' "$line" | tr -d '\r' | awk '{print $1}')"
  else
    meta="$(grep -RIl --include='SHA256SUMS.*' -e "  $base\$" "$META_DIR" | head -1 || true)"
    [[ -z "$meta" ]] && { [[ $QUIET -eq 0 ]] && echo "[NO META] $base"; return 2; }
    hmeta="$(grep -F -- "  $base" "$meta" | head -1 | tr -d '\r' | awk '{print $1}')"
  fi

  hfile="$(sha256sum -- "$f" | awk '{print $1}')"
  if [[ "$hfile" == "$hmeta" ]]; then
    [[ $QUIET -eq 0 ]] && echo "[OK] $base"
    return 0
  else
    [[ $QUIET -eq 0 ]] && echo "[MISMATCH] $base (file=$hfile meta=$hmeta) [meta=$(basename "$meta")]"
    return 1
  fi
}

# =========================
# 디렉토리 준비
# =========================
mkdir -p "$META_DIR" "$FINAL_OUT"
if [[ $VERIFY_ONLY -eq 0 ]]; then
  mkdir -p "$CORE_OUT/CORE"
  if [ -d "$HDD" ]; then
    mkdir -p "$HDD_AR/FULL" "$HDD_AR/CHECKPOINTS" "$HDD_AR/META" "$HDD_AR/INCR"
    [[ $QUIET -eq 0 ]] && echo "[INFO] HDD 디렉토리 생성 완료: $HDD_AR"
  else
    [[ $QUIET -eq 0 ]] && echo "[WARN] HDD 마운트되지 않음: $HDD (HDD 이관 건너뜀)"
  fi
fi

# =========================
# 복사 래퍼
# =========================
copy() {
  local src="$1" dst="$2"
  if [ "$APPLY" = "1" ]; then
    mkdir -p "$(dirname "$dst")"
    rsync -a --info=NAME,PROGRESS2 -- "$src" "$dst"
  else
    if [[ $VERIFY_ONLY -eq 1 ]]; then
      [[ $QUIET -eq 0 ]] && echo "[VERIFY-SKIP] $src"
    else
      [[ $QUIET -eq 0 ]] && echo "[DRY] $src -> $dst"
    fi
  fi
}

[[ $QUIET -eq 0 ]] && echo "== apply.sh :: APPLY=$APPLY VERIFY_ONLY=$VERIFY_ONLY KEEP_TMP=$KEEP_TMP FULL_MANIFEST=$FULL_MANIFEST QUIET=$QUIET =="
[[ $QUIET -eq 0 ]] && echo "[PLAN] $PLAN"

# =========================
# 메인 실행부
# =========================
if [[ $VERIFY_ONLY -eq 0 ]]; then
  [[ $QUIET -eq 0 ]] && echo "== [APPLY MODE] 파일 이관 및 메타 생성 수행 =="

  # 1) 이관
  [[ $QUIET -eq 0 ]] && echo "[1/3] 백업 파일 이관:"
  jq -r 'if type=="array" then .[] else . end | .src' "$PLAN" | while IFS= read -r f; do
    [[ -z "$f" ]] && continue
    base="$(basename "$f")"
    [[ $QUIET -eq 0 ]] && echo "[COPY] $base"
    if [ -d "$HDD" ]; then
      subdir="$( [[ $base == FULL__* ]] && echo FULL || echo INCR )"
      copy "$f" "$HDD_AR/$subdir/$base"
    else
      [[ $QUIET -eq 0 ]] && echo "[SKIP] HDD 없음: $base"
    fi
  done

  # 2) SHA256SUMS
  [[ $QUIET -eq 0 ]] && echo "[2/3] SHA256SUMS 메타데이터 생성:"
  jq -r 'if type=="array" then .[] else . end | select(.sha256 != null) | "\(.src)|\(.sha256)"' "$PLAN" \
  | while IFS='|' read -r f hash; do
      [[ -z "$f" ]] && continue
      base="$(basename "$f")"
      meta_file="$META_DIR/SHA256SUMS.${base%.tar.zst}.txt"
      printf "%s  %s\n" "$hash" "$base" > "$meta_file"
      [[ $QUIET -eq 0 ]] && echo "[META] 생성: $meta_file"
      [ -d "$HDD" ] && copy "$meta_file" "$HDD_AR/META/$(basename "$meta_file")"
    done

  # 3) GOLD
  [[ $QUIET -eq 0 ]] && echo "[3/3] GOLD FULL 메타데이터 생성:"
  GOLD="$(ls -1t "$HDD_AR/FULL"/FULL__*.tar.zst 2>/dev/null | head -1 || true)"
  if [[ -n "$GOLD" ]]; then
    base="$(basename "$GOLD")"
    src_from_plan="$(jq -r --arg b "$base" 'if type=="array" then .[] else . end | select(.src|endswith($b)) | .src' "$PLAN" | head -1 || true)"
    meta="$META_DIR/${base%.tar.zst}.GOLD.txt"
    {
      echo "GOLD_FULL=$base"
      echo "SOURCE_PATH=${src_from_plan:-UNKNOWN}"
      echo "HDD_PATH=$HDD_AR/FULL/$base"
    } > "$meta"
    copy "$meta" "$FINAL_OUT/"
    [[ $QUIET -eq 0 ]] && echo "[GOLD] 최신 GOLD 지정: $base"
  fi

  # 4) 봉인
  if [ "$APPLY" = "1" ]; then
    chmod -R a-w "$CORE_OUT/CORE" 2>/dev/null || true
    fs="$(stat -f -c %T "$USB" 2>/dev/null || echo '?')"
    [[ "$fs" =~ ext4|ext2 ]] && sudo chattr +i "$CORE_OUT/CORE"/* 2>/dev/null || true
  fi
fi

# =========================
# 검증 & 요약
# =========================
[[ $QUIET -eq 0 ]] && { echo; echo "===================="; echo "[VERIFY & SUMMARY]"; echo "===================="; }

tmpdir="$(mktemp -d)"
# 검증(집계) 구간: 실패/미정의 변수로 중단되지 않도록
set +e
set +u

# --- 목록 초기화 ---
: > "$tmpdir/full.list"
: > "$tmpdir/incr.list"

# PLAN에서 FULL/INCR 대상 추출 (JSONL/배열 모두 대응, CRLF 방지)
jq -r 'if type=="array" then .[] else . end
       | select(.src|test("/FULL__"))
       | (.src|capture("(?<name>FULL__.*)").name)' "$PLAN" | tr -d '\r' >> "$tmpdir/full.list" || true
jq -r 'if type=="array" then .[] else . end
       | select(.src|test("/INCR__"))
       | (.src|capture("(?<name>INCR__.*)").name)' "$PLAN" | tr -d '\r' >> "$tmpdir/incr.list" || true

# Fallback: PLAN이 비어 있으면 디렉토리 스캔
if [[ ! -s "$tmpdir/full.list" ]] && [[ -d "$FULL_DIR" ]]; then
  (cd "$FULL_DIR" && ls -1 FULL__*.tar.zst 2>/dev/null) >> "$tmpdir/full.list" || true
fi
if [[ ! -s "$tmpdir/incr.list" ]] && [[ -d "$INCR_DIR" ]]; then
  (cd "$INCR_DIR" && ls -1 INCR__*.tar.zst 2>/dev/null) >> "$tmpdir/incr.list" || true
fi

[[ $KEEP_TMP -eq 0 ]] && trap 'rm -rf "$tmpdir"' EXIT

FULL_DIR="$HDD_AR/FULL"
INCR_DIR="$HDD_AR/INCR"

ok_full=0; bad_full_cnt=0; ok_incr=0; bad_incr_cnt=0

# FULL 루프
while IFS= read -r base; do
  [[ -z "$base" ]] && continue
  base="${base%%$'\r'}"
  f="$FULL_DIR/$base"
  if [[ ! -f "$f" ]]; then
    [[ $QUIET -eq 0 ]] && echo "[MISS-FULL] $base"
    (( bad_full_cnt++ ))
    continue
  fi
  if check_one_exact "$f" >/dev/null; then
    (( ok_full++ ))
  else
    (( bad_full_cnt++ ))
  fi
done < "$tmpdir/full.list"

# INCR 루프
while IFS= read -r base; do
  [[ -z "$base" ]] && continue
  base="${base%%$'\r'}"
  f="$INCR_DIR/$base"
  if [[ ! -f "$f" ]]; then
    [[ $QUIET -eq 0 ]] && echo "[MISS-INCR] $base"
    (( bad_incr_cnt++ ))
    continue
  fi
  if check_one_exact "$f" >/dev/null; then
    (( ok_incr++ ))
  else
    (( bad_incr_cnt++ ))
  fi
done < "$tmpdir/incr.list"

# ---- BEGIN: unified summary & deterministic exit ----
set -e
set -u

total_full=$(awk 'NF{c++} END{print c+0}' "$tmpdir/full.list" 2>/dev/null)
total_incr=$(awk 'NF{c++} END{print c+0}' "$tmpdir/incr.list" 2>/dev/null)
rc=$(( bad_full_cnt + bad_incr_cnt ))

# 전수 출력은 FULL_MANIFEST & !QUIET에서만
if [[ $FULL_MANIFEST -eq 1 && $QUIET -eq 0 ]]; then
  echo "— FULL 전수 결과"; while IFS= read -r f; do [[ -n "$f" ]] && check_one_exact "$FULL_DIR/$f" || true; done < "$tmpdir/full.list"
  echo "— INCR 전수 결과"; while IFS= read -r f; do [[ -n "$f" ]] && check_one_exact "$INCR_DIR/$f" || true; done < "$tmpdir/incr.list"
fi

if [[ $QUIET -eq 0 ]]; then
  echo
  echo "===================="
  echo "SUMMARY"
  echo "===================="
  printf "개수: FULL 기대=%d 실제=%d | INCR 기대=%d 실제=%d\n" \
    "$total_full" "$(ls -1 "$FULL_DIR" 2>/dev/null | wc -l)" \
    "$total_incr" "$(ls -1 "$INCR_DIR" 2>/dev/null | wc -l)"
  printf "무결성: FULL OK=%d BAD=%d | INCR OK=%d BAD=%d\n" \
    "$ok_full" "$bad_full_cnt" "$ok_incr" "$bad_incr_cnt"
  if (( rc==0 )); then
    echo "[ALL GREEN] 무결성 이상 없음 ✅"
  else
    echo "[ATTENTION] 무결성 불일치 존재 ❗"
  fi
fi

# JSON 요약 출력 (환경변수 JSON_SUMMARY=1 또는 --json-summary 옵션 시)
if [[ ${JSON_SUMMARY:-0} -eq 1 || " $* " == *" --json-summary "* ]]; then
  printf '{"full_expected":%d,"incr_expected":%d,"full_ok":%d,"full_bad":%d,"incr_ok":%d,"incr_bad":%d,"rc":%d}\n' \
    "$total_full" "$total_incr" "$ok_full" "$bad_full_cnt" "$ok_incr" "$bad_incr_cnt" "$rc"
fi

exit $rc
# ---- END: unified summary & deterministic exit ----
