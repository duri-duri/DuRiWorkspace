#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Trace v2 실벤치 - Python 구현
CI 가드 호환: --version, --self-check 지원
Day 20/21 스크립트 계약 준수
"""
import argparse
import json
import sys
import time
import os

VERSION = "v0.1.0"

def main():
    parser = argparse.ArgumentParser(description="Trace v2 실벤치")
    
    # Global flags
    parser.add_argument("--version", action="store_true", help="print version and exit")
    parser.add_argument("--self-check", action="store_true", help="run internal checks and print TRACE_BENCH_OK line")
    
    # Bench flags (align with Day20/21 scripts)
    parser.add_argument("--sampling", type=float, default=1.0, help="sampling rate in [0,1]")
    parser.add_argument("--serialization", default="json", choices=["json", "msgpack", "protobuf"], help="serialization format")
    parser.add_argument("--compression", default="none", choices=["none", "gzip", "zstd"], help="compression format")
    parser.add_argument("--json-out", help="write JSON result to this path")
    
    args = parser.parse_args()
    
    if args.version:
        print(f"trace_bench {VERSION}")
        return
    
    if args.self_check:
        # Minimal invariants to satisfy CI guard & runner contract
        if not validate_inputs(1.0, "json", "none"):
            print("TRACE_BENCH_OK: false")
            sys.exit(2)
        print("TRACE_BENCH_OK: true")
        return
    
    # Bench mode
    if not validate_inputs(args.sampling, args.serialization, args.compression):
        print("[ERR] Invalid inputs", file=sys.stderr)
        sys.exit(1)
    
    # === 연결 포인트(핵심): 실제 계측 로직을 여기에 삽입 ===
    result = model_based_estimation(args.sampling, args.serialization, args.compression)
    
    # 출력 경로 결정
    if args.json_out:
        # 원자적 쓰기
        tmp = args.json_out + ".tmp"
        with open(tmp, 'w') as f:
            json.dump(result, f, indent=None, separators=(',', ':'))
        os.rename(tmp, args.json_out)
        print(f"[BENCH] sampling={args.sampling}, ser={args.serialization}, comp={args.compression} -> {args.json_out}", file=sys.stderr)
    else:
        # stdout로 내보내기
        print(json.dumps(result, indent=None, separators=(',', ':')))

def validate_inputs(sampling, serialization, compression):
    """입력 검증"""
    if not (0.0 <= sampling <= 1.0):
        return False
    if serialization not in ["json", "msgpack", "protobuf"]:
        return False
    if compression not in ["none", "gzip", "zstd"]:
        return False
    return True

def model_based_estimation(sampling, ser, comp):
    """실제 계측 로직 자리에 있는 결정론적 추정기"""
    # 기준선(예: 750ms, 100KB)
    base_p95 = 750.0
    base_size = 100.0
    base_err = 0.0020  # 0.2%
    
    # Serialization/Compression 계수
    ser_mul = {
        "json": 1.00,
        "msgpack": 0.96,
        "protobuf": 0.94,
    }[ser.lower()]
    
    comp_mul = {
        "none": 1.00,
        "gzip": 0.98,
        "zstd": 0.96,
    }[comp.lower()]
    
    # p95: 샘플링↑ → 오버헤드↓ 가정
    p95 = base_p95 * (1.02 - 0.15 * sampling) * ser_mul * comp_mul
    if p95 < 1:
        p95 = 1
    
    # error_rate: 샘플링↑ → 수집 안정성↑(약간) 가정
    err_rate = base_err * (1.04 - 0.20 * sampling)
    if err_rate < 0:
        err_rate = 0
    
    # size_kb: 샘플링↑ 및 직렬화/압축에 비례
    ser_size_mul = {
        "json": 1.00,
        "msgpack": 0.85,
        "protobuf": 0.80,
    }[ser.lower()]
    comp_size_mul = {
        "none": 1.00,
        "gzip": 0.70,
        "zstd": 0.55,
    }[comp.lower()]
    size_kb = base_size * (0.60 + 0.50 * sampling) * ser_size_mul * comp_size_mul
    if size_kb < 0:
        size_kb = 0
    
    # 최소 실행시간(실측 대체 구간 표시/동기화용): 10~30ms 대기
    time.sleep(0.015)  # 15ms
    
    return {
        "p95_ms": round(p95, 2),
        "error_rate": round(err_rate, 5),
        "size_kb": round(size_kb, 2),
    }

if __name__ == "__main__":
    main()
