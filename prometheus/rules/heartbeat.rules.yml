groups:
- name: heartbeat
  interval: 15s
  rules:
  # Recording rule: Heartbeat changes (number of changes in 6m window)
  # Window: 6m = HB(60s) + 2*SI(30s) + ε for safety margin
  # changes() works with gauge metrics and counts value changes
  # Filter by metric_realm="prod" to avoid legacy series
  # This is the raw count of changes (for debugging/monitoring)
  - record: duri_heartbeat_changes_6m
    expr: changes(duri_textfile_heartbeat_seq{metric_realm="prod"}[6m])
  
  # Recording rule: Heartbeat freshness (recent sample within 120s)
  # Uses max_over_time(timestamp(...)) for robustness against initial gaps
  # Convert boolean to 0/1 with clamp_max and explicit scalar multiplication
  # Missing values coalesced to 0 (operational safety)
  # Fallback to 0 for initial gaps (reload resilience)
  - record: duri_heartbeat_fresh_120s
    expr: |
      clamp_max(
        (
          (time() - max_over_time(timestamp(duri_textfile_heartbeat_seq{metric_realm="prod"})[120s])) <= bool 120
        ) * 1,
        1
      ) or on() vector(0)
  
  # Recording rule: Heartbeat OK (1 = healthy, 0 = stalled)
  # OK if: changes > 0 AND fresh_120s > 0 (both conditions must be met)
  # Explicit scalar multiplication for bool→num conversion
  # This is the normalized 0/1 gauge for decision-making
  - record: duri_heartbeat_ok
    expr: |
      clamp_max(
        (
          (duri_heartbeat_changes_6m > 0) * (duri_heartbeat_fresh_120s > 0)
        ) * 1,
        1
      )
  
  # Recording rule: Heartbeat stall detection (for alerts)
  # Stall if: ok == 0 (inverse of OK)
  # Convert boolean to 0/1 and clamp
  - record: duri_heartbeat_stall
    expr: |
      clamp_max(
        ((duri_heartbeat_ok == 0) * 1),
        1
      )
